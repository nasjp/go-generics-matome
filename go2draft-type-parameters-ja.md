# 型パラメータ - ドラフトデザイン

イアン・ランス・テイラー\
ロバート・グリセマー\
2020/6/16

## 要旨

Go言語を拡張して、型や関数にオプションの型パラメータを追加することを提案します。
型パラメータはインターフェイス型によって制約されることがあります。
また、型制約として使用される場合には、インターフェイス型を拡張して、それらに割り当てられる可能性のある型のセットをリストアップできるようにすることを提案します。
多くの場合、関数呼び出しから型引数を省略できるように、統一アルゴリズムによる型推論がサポートされています。
この設計はGo 1と完全に下位互換性があります。

## ドラフトデザインの読み方

この資料は長いです。
読み方のガイダンスをご紹介します。

* 最初にハイレベルの概要を説明し、概念を非常に簡単に説明します。
* その後、ゼロから始める完全な設計を説明し、必要に応じて詳細を簡単な例を用いて紹介します。
* デザインが完全に説明された後、実装、デザインのいくつかの問題点、そしてジェネリクスへの他のアプローチとの比較について議論します。
* このデザインが実際にどのように使われるのか、いくつかの完全な例を紹介します。
* 例に続いて、いくつかの細かい詳細は付録で議論されています。

## 非常にハイレベルの概要

このセクションでは、ドラフトデザインで提案された変更点を非常に簡単に説明します。
このセクションは、Goのような言語でジェネリクスがどのように機能するのかをすでに知っている方を対象としています。
これらの概念については、次のセクションで詳しく説明します。

* 関数は、キーワード`type`で導入される追加の型パラメータリストを持つことができます: `func F(type T)(p T) { ... }`
* これらの型のパラメータは、通常のパラメータと関数本体で使用することができます。
* 型は型のパラメータリストを持つこともできます。`type M(type T) []T`
* 各型パラメータはオプションの型制約を持つことができます： `func F(type T Constraint)(p T) { ... }`
* 型制約はインターフェイス型です。
* 型制約として使用されるインターフェイス型は、事前に宣言された型のリストを持つことができます。
* 一般的な関数や型を使用する場合は、型の引数を渡す必要があります。
* 型推論では、一般的なケースでは型引数を省略することができます。
* 型パラメータに型制約がある場合、その型の引数はインターフェイスを実装しなければなりません。
* ジェネリクス関数は、型制約で許可された操作のみを使用することができます。

以下のセクションでは、これらの言語の変更点を詳細に説明します。
このデザインドラフトで書かれた一般的なコードが実際にどのように見えるかを見るために、[例](#例)へ進むことを好むかもしれません。

## 背景

このバージョンのデザインドラフトは、2019年7月31日に発表されたものと多くの類似点がありますが、制約は削除され、インターフェース型に置き換えられています。

Goには、これまでにも多くの[ジェネリクスプログラミングの追加サポートの要望](https://github.com/golang/go/wiki/ExperienceReports#generics)がありました。
[issue tracker](https://golang.org/issue/15292) や [a living document](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view) で広範囲の議論が行われています。

型のパラメータを追加するための提案がいくつかありますが、それらは上記のリンクから見つけることができます。
ここで紹介されているアイデアの多くは、以前にも登場しています。
ここで説明されている主な新機能は、シンタックスと、制約としてのインタフェース型の精査です。

このデザインドラフトは、Go言語を拡張してパラメトリックなポリフォーリズムを追加することを提案しています。
ここでは、型パラメータは（いくつかのオブジェクト指向言語のように）宣言されたサブタイプ関係ではなく、明示的に定義された構造制約によって拘束されます。

このデザインは、テンプレートのメタプログラミングや他の形式のコンパイル時プログラミングをサポートしていません。

Goコミュニティでは _ジェネリクス(generic)_ という用語が広く使われているので、以下では、型のパラメータを取る関数や型を意味する略語として使用します。
このデザインで使用されているジェネリクスという用語を、C++、C#、Java、Rustなどの他の言語の同じ用語と混同しないでください。

## 設計

完成した設計を簡単な事例をもとに段階的に記述していきます。

### 型パラメータ

ジェネリクスコードとは、後に指定する型を使って書かれたコードのことです。
不特定の型のことを_type parameter_と呼びます。
ジェネリクスコードを実行すると、typeパラメータに_type argument_が設定されます。

ここではスライスの各要素をプリントアウトする関数を示します。
これは、ジェネリクスプログラミングをサポートするために許可したい関数の種類の些細な例です。
(後に[ジェネリクス型](#ジェネリクス型)についても触れます。)

```Go
// Printはスライスの要素をプリントします。
// これは、任意のスライス値で呼び出すことができるはずです。
func Print(s []T) { // ただの例であって、提案された構文ではありません。
	for _, v := range s {
		fmt.Println(v)
	}
}
```

このアプローチでは、最初に決定すべきことは、型パラメータ `T` をどのように宣言すべきかということです。
Goのような言語では、すべての識別子が何らかの方法で宣言されることを期待しています。

ここで設計上の決定をします。型パラメータは通常の非型関数パラメータと似ているので、他のパラメータと一緒にリストアップします。
しかし、型パラメータは非型パラメータと同じではないので、パラメータのリストには表示されますが、区別したいのです。
これが次の設計上の決定につながります。型パラメータを記述する追加のオプションのパラメータリストを定義します。
このパラメータリストは、通常のパラメータの前に表示されます。
キーワード `type` で始まり、型パラメータを列挙します。

```Go
// Printは、任意のスライスの要素をプリントします。
// Printは、単一の非型パラメータTを持ちます。
// その型のパラメータのスライスであるパラメータs
func Print(type T)(s []T) {
	// 同上
}
```

これは、関数 `Print` の中で識別子 `T` が型パラメータであり、現在は不明だが関数が呼び出されたときにはわかるような型であることを示しています。
上で見たように、型パラメータは通常の非型パラメータを記述する際に型として使われることがあります。
また、関数の本文の中で使用されることもあります。

`Print`は型パラメータを持つので、`Print`の呼び出しはすべて型引数を与えなければならない。
後で、[関数引数の型推論](#関数引数の型推論)を使って、型引数が通常どのようにして非型引数から推論されるかを見てみましょう。
今のところは、明示的に型引数を渡します。
型引数は型パラメータが宣言されるのと同じように、別の引数リストとして渡されます。
呼び出し元では、`type`キーワードは使用されません。

```Go
// Printを[]intで呼び出します。
// Printには型パラメータTがあり、[]intを渡したいのです。
// なので、Print(int)を書くことでint型の引数を渡します。
// 関数Print(int)は引数に[]intを渡します。

Print(int)([]int{1, 2, 3})

// これは次のようにプリントされます。
// 1
// 2
// 3
```

### 成約

この例をもう少し複雑にしてみましょう。
各要素に対して `String` メソッドを呼び出して、任意の型のスライスを `[]string` に変換する関数に変えてみましょう。

```Go
// この関数は無効です。
func Stringify(type T)(s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String()) // 無効
	}
	return ret
}
```

一見するとこれでいいように思えるかもしれませんが、この例では `v` は `T` 型を持ち、`T` については何もわかりません。
特に、`T` が `String` メソッドを持っていることもわかりません。
したがって、`v.String()` の呼び出しは無効です。

当然のことながら、ジェネリクスプログラミングをサポートする他の言語でも同じ問題が発生します。
例えば、C++では、ジェネリクス関数（C++用語では、関数テンプレート）は、ジェネリクス型の値に対して任意のメソッドを呼び出すことができます。
つまり、C++のアプローチでは、`v.String()`を呼び出しても問題ありません。
型の引数に`String`メソッドを持たない関数が呼び出された場合、その型の引数を持つ`v.String`への呼び出しをコンパイルする際にエラーが報告されます。
このようなエラーは、エラーが発生するまでにジェネリクス関数の呼び出しが何層にもわたっていることがあるので、何が間違っていたのかを理解するためには、そのすべてを報告しなければなりません。

C++のアプローチはGoには向かないでしょう。
その理由の一つは、言語のスタイルにあります。
Goでは、この場合の`String`のように名前を参照して、名前が存在することを期待することはありません。
Goは、すべての名前を見たときに、その名前の宣言を解決します。

もう一つの理由は、Go はスケールでのプログラミングをサポートするように設計されているからです。
ジェネリクス関数の定義(上記の `Stringify`)とジェネリクス関数の呼び出し(図示されていませんが、おそらく他のパッケージに含まれていると思われます)が離れている場合を考えなければなりません。
一般的に、すべてのジェネリクスコードは型引数が特定の要件を満たすことを期待しています。
我々はこれらの要件を_成約(constraints)_と呼んでいます（他の言語では、型の境界、トレイトの境界、または概念として知られている同様の考え方があります）。
この場合、制約は非常に明白です: 型は `String() string` メソッドを持たなければなりません。
他のケースでは、もっと明白ではないかもしれません。

制約は、`Stringify`が何をするにしても（この場合、`String`メソッドを呼び出すにしても）、その制約を導出したくありません。
もしそうすると、`Stringify` を少し変更しただけで制約が変更される可能性があります。
つまり、ちょっとした変更で、その関数を呼び出す遠く離れたコードが予期せず壊れてしまう可能性があるということです。
`Stringify`が意図的に制約を変更して、ユーザに変更を強制するのは構いません。
私たちが避けたいのは、`Stringify`が偶然に制約を変更することです。

これは、制約が呼び出し元によって渡される型引数とジェネリクス関数のコードの両方に制限を設定しなければならないことを意味します。
呼び出し元は、制約を満たす型引数のみを渡すことができます。
ジェネリクス関数は、制約によって許可された方法でのみ、これらの値を使用することができます。
これは、Goでジェネリクスプログラミングを定義しようとする場合に適用すべき重要なルールです。
ジェネリクスコードは、その型引数が実装されていることが知られている操作しか使用できません。

### どのような型でも操作が許可されていた場合

制約について議論する前に、制約がない場合に何が起こるかを簡単に説明します。
上述の`Print`メソッドのように、ジェネリクス関数が型パラメータに対して制約を指定していない場合、その型パラメータに対しては、どのような型の引数も許可されます。
ジェネリクス関数がその型パラメータの値で使用できる操作は、任意の型の値に対して許可されている操作のみです。
上の例では、`Print`関数は型パラメータ`T`を型とする変数`v`を宣言し、その変数を関数に渡しています。

どのような型でも許される操作は

* これらの型の変数を宣言する
* これらの変数に同じ型の他の値を代入する
* これらの変数を関数に渡すか、関数から返すかします。
* これらの変数のアドレスを取る
* これらの型の値を`interface{}`型に変換したり，代入したりします．
* 型`T`の値を型`T`に変換します (許可されていますが無駄です)
* インターフェイスの値を型に変換するために、型アサーションを使用します。
* タイプスイッチのケースとして型を使用する
* その型のスライスなど、それらの型を使用する複合型を定義して使用します。
* 型を`new`のような組み込み関数に渡します。

将来の言語変更により、このような操作が追加される可能性はありますが、現在のところ何も予想されていません。

### 制約の定義

Goには、制約に必要なものに近い構成要素がすでにあります。
インターフェース型はメソッドの集合です。
インターフェース型の変数に代入できる値は、その型が同じメソッドを実装しているものだけです。
インターフェース型の値でできる操作は、任意の型で許可されている操作以外では、メソッドを呼び出すことだけです。

型の引数を持つジェネリクス関数を呼び出すことは、インターフェース型の変数に代入することに似ています：型の引数は、型パラメータの制約を実装しなければなりません。
ジェネリクス関数を書くことは、インターフェース型の値を使うことに似ています。
ジェネリクスコードは、制約によって許可された操作（または任意の型に対して許可された操作）のみを使うことができます。

この設計では、制約は単にインタフェース型です。
制約を実装することは、単純にインターフェース型を実装することになります。
(後に、[演算子](#演算子)のように、メソッド呼び出し以外の操作に対して制約を定義する方法を見ていきます。)

`Stringify` の例では、引数を取らずに `String` 型の値を返す `String` メソッドを持つインタフェース型が必要です。

```Go
// Stringerは型制約であり、型の引数が
// Stringメソッドを作成し、ジェネリクス関数がStringを呼び出すことを許可します。
// Stringメソッドは、値の文字列表現を返す必要があります。
type Stringer interface {
	String() string
}
```

(この議論には関係ありませんが、これは標準ライブラリの`fmt.Stringer`型と同じインタフェースを定義しており、実際のコードでは単に`fmt.Stringer`を使うことになるでしょう。)

### 制約を使う

ジェネリクス関数では、制約は型引数の型、つまりメタ型と考えることができます。
つまり、ジェネリクス関数は制約を使用する必要はありませんが、制約を使用する場合は、型パラメータのメタ型として型パラメータリストにリストされます。

```Go
// Stringifyは、sの各要素に対してStringメソッドを呼び出します。
// そして、その結果を返します。
func Stringify(type T Stringer)(s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String())
	}
	return ret
}
```

単一の型パラメータ `T` の後には、`T` に適用される制約(今回は、`Stringer`)が続きます。

### 複数の型パラメータ

`Stringify` の例では単一の型パラメータしか使わないが、関数は複数の型パラメータを持つことができます。

```Go
// Print2には2つの型パラメータと2つの非型パラメータがあります。
func Print2(type T1, T2)(s1 []T1, s2 []T2) { ... }
```

これと比較してみてください。

```Go
// Print2Sameには1つの型パラメータと2つの非型パラメータがあります。
func Print2Same(type T)(s1 []T, s2 []T) { ... }
```

`Print2` では `s1` と `s2` は異なる型のスライスであっても構いません。
`Print2Same` では、`s1` と `s2` は同じ要素型のスライスでなければなりません。

各型のパラメータは、独自の制約を持つことができます。

```Go
// Stringerは、Stringメソッドを必要とする型制約です。
// Stringメソッドは、値を文字列で表現したものを返す必要があります。
type Stringer interface {
	String() string
}

// Plusserは、Plusメソッドを必要とする型制約です。
// Plusメソッドは、引数を内部文字列に追加して結果を返すことが期待されています。
type Plusser interface {
	Plus(string) string
}

// ConcatToはStringメソッドで要素のスライスを取得し、Plusメソッドでも要素のスライスを取得します。
// スライスは同じ数の要素を持つ必要があります。
// sの各要素を文字列に変換し、それをpの対応する要素のPlusメソッドに渡して、結果の文字列のスライスを返します。
func ConcatTo(type S Stringer, P Plusser)(s []S, p []P) []string {
	r := make([]string, len(s))
	for i, v := range s {
		r[i] = p[i].Plus(v.String())
	}
	return r
}
```

型パラメータに制約が指定されている場合、すべての型パラメータは制約を持たなければなりません。
型パラメータの中に制約が必要なものとそうでないものがある場合、そうでないものは `interface{}` の制約を持つべきです。

```Go
// StrAndPrintは、任意の型のラベルのスライスと、
// Stringメソッドを持たなければならない値のスライスを取り、
// 値を文字列に変換し、
// ラベル付けされた文字列をPrintします。
func StrAndPrint(type L interface{}, T Stringer)(labels []L, vals []T) {
	// Stringifyは上記で定義されています。これは[]stringを返します。
	for i, s := range Stringify(vals) {
		fmt.Println(labels[i], s)
	}
}
```

1つの制約は、複数の型パラメータに使用できます。
制約は、各型パラメータに個別に適用されます。

```Go
// Stringify2は，異なる型の2つのスライスを文字列に変換し，
// すべての文字列を連結したものを返します．
func Stringify2(type T1, T2 Stringer)(s1 []T1, s2 []T2) string {
	r := ""
	for _, v1 := range s1 {
		r += v1.String()
	}
	for _, v2 := range s2 {
		r += v2.String()
	}
	return r
}
```

### ジェネリクス型

私たちはジェネリクス関数だけではなく、ジェネリクス型も欲しいと考えています。
私たちは、型を拡張して型のパラメータを取ることを提案します。

```Go
type Vector(type T) []T
```

型のパラメータは関数の型パラメータと同じです。

型の定義内では、型のパラメータは他の型と同様に使用することができます。

ジェネリクス型を使用するには、型の引数を与えなければなりません。
これは関数の呼び出しのように見えますが、この場合の関数は実際には型です。
これは _インスタンス化(instantiation)_ と呼ばれています。
型パラメータに型引数を供給して型をインスタンス化すると、
型定義における型パラメータの各使用が対応する型引数に置き換えられた型が生成されます。

```Go
// vはint値のVectorです。
//
// これは、"Vector(int) "が有効な識別子であるかのように見せかけて、
// 下記のようにを書いているのと似ています。
//   type "Vector(int)" []int
//   var v "Vector(int)"
// Vector(int)の全使用箇所は、同じ "Vector(int)" 型を参照します。
//
var v Vector(int)
```

ジェネリクス型はメソッドを持つことができます。
メソッドのレシーバ型は、レシーバ型の定義で宣言されているのと同じ数の型パラメータを宣言しなければなりません。
これらのパラメータは、`type`キーワードや制約なしに宣言されます。

```Go
// Pushは、ベクトルの末尾に値を追加します。
func (v *Vector(T)) Push(x T) { *v = append(*v, x) }
```

メソッド宣言に列挙された型パラメータは、型宣言の型パラメータと同じ名前を持つ必要はありません。
特に、メソッドで使用されない場合は `_` とすることができます。

ジェネリクス型は、型が通常自分自身を参照できる場合には自分自身を参照することができますが、
その場合、型の引数は型のパラメータを同じ順序で列挙しなければなりません。
この制限により、型のインスタンス化の無限再帰を防ぐことができます。

```Go
// Listは、型Tの値の連結リストです。
type List(type T) struct {
	next *List(T) // List(T)への参照はOK
	val  T
}

// この型は不正です。
type P(type T1, T2) struct {
	F *P(T2, T1) // (T1, T2)でなければなりません。
}
```

この制限は、直接参照と間接参照の両方に適用されます。

```Go
// ListHeadは、連結リストの先頭です。
type ListHead(type T) struct {
	head *ListElement(T)
}

// ListElementは、headを持つ連結リストの要素です。
// 各要素は先頭を指し示します。
type ListElement(type T) struct {
	next *ListElement(T)
	val  T
  // ここではListHead(T)はOK
  // ListHead(T)はListElement(T)を参照し、ListElement(T)はListHead(T)を参照します。
	// ListHead(T) は ListHead(int) への間接参照を持っているため、ListHead(int) を使用しても問題ありません。
	head *ListHead(T)
}
```

(注意: 人々がどのようにコードを書きたいのかをより理解した上で、
異なる型の引数を使用するいくつかのケースを許可するために、
このルールを緩和することが可能かもしれません。)

ジェネリクス型の型パラメータには制約がある場合があります。

```Go
// StringableVectorは、何らかの型のスライスであり、
// その型はStringメソッドを持たなければなりません。
type StringableVector(type T Stringer) []T

func (s StringableVector(T)) String() string {
	var sb strings.Builder
	for i, v := range s {
		if i > 0 {
			sb.WriteString(", ")
		}
    // vはT型であり、Tの制約はStringerなので、ここではv.Stringを呼んでも問題ありません。
		sb.WriteString(v.String())
	}
	return sb.String()
}
```

### メソッドは追加の型の引数を取ることはできません。

ジェネリクス型のメソッドは型のパラメータを使用することができますが、メソッド自体が型のパラメータを追加することはできません。
メソッドに型の引数を追加することが有用な場合、適切にパラメータ化されたトップレベル関数を書かなければなりません。

これについては [問題点](#パラメータ化されていないメソッド)にてより多くの議論があります。

### 演算子

これまで見てきたように、インターフェイス型を制約として使用しています。
インターフェース型はメソッドのセットを提供し、それ以外は何も提供しません。
つまり、これまで見てきたことを考えると、
ジェネリクス関数が型のパラメータの値を使ってできることは、
どの型でも許されている操作以外には、
メソッドを呼び出すことしかないということになります。

しかし、メソッドの呼び出しだけでは表現したいことのすべてに十分ではありません。
スライスが空でないことを前提とした値のスライスの最小要素を返すこの単純な関数を考えてみましょう。

```Go
// 不正
func Smallest(type T)(s []T) T {
	r := s[0] // スライスが空だとpanicが起こる
	for _, v := range s[1:] {
		if v < r { // 不正
			r = v
		}
	}
	return r
}
```

合理的なジェネリクスの実装であれば、この関数を書くことができるはずです。
問題は `v < r` という式です。
これは `T` が `<` 演算子をサポートしていることを前提としていますが、`T` には制約がありません。
制約がなければ、関数 `Smallest` はすべての型で利用可能な演算しか使えませんが、
すべてのGoの型が `<` をサポートしているわけではありません。
残念ながら、`<`はメソッドではないので、`<`を許可する制約(インタフェース型)を書く明白な方法はありません。

サポートする型のみを受け入れる制約を記述する方法が必要です。
そのためには、後述する2つの例外を除いて、
その言語で定義されているすべての算術演算子、比較演算子、論理演算子は、
その言語で事前に宣言されている型、あるいは、その基になる型が事前に宣言されている型の1つである定義済みの型でのみ使用することができるということを理解しておきましょう。
つまり、演算子 `<` は `int` や `float64` のような事前に宣言された型、
またはその基になる型がこれらの型のいずれかである定義済みの型に対してのみ使用することができます。
Goでは、複合型や任意の定義型で `<` を使うことはできません。

つまり、`<`に対する制約を書こうとするのではなく、逆の方法でこれに取り組むことができます。

#### 制約内の型リスト

制約として使用されるインタフェース型は、型の引数として使用できる明示的な型をリストアップすることができます。
これは、`type`キーワードの後にカンマで区切られた型のリストを続けて使用します。

例:

```Go
// SignedIntegerは、任意の符号付き整数型を許可する型制約です。
type SignedInteger interface {
	type int, int8, int16, int32, int64
}
```

`SignedInteger`制約は、型の引数がリストされた型のいずれかでなければならないことを指定する。
より正確には、型の引数の基礎となる型は、型リストの型の一つと同一でなければなりません。
これは、`SignedInteger`はリストにある整数型を受け入れ、
それらの型のいずれかとして定義されている型も受け入れることを意味する。

ジェネリクス関数がこれらの制約のいずれかを持つ型パラメータを使用する場合、
リストされたすべての型で許可されている操作を使用することができます。
これは、`<`, `range`, `<-`などのような操作です。
制約にリストされた各型を使用して関数を正常にコンパイルできれば、
その操作は許可されます。

1つの制約は1つの型リストしか持てません。

先ほどの`Smallest`の例では、次のような制約を使うことができます。

```Go
package constraints

// Orderedは、任意の順序付き型にマッチする型制約です。
// 順序付き型とは、<, <=, >, >=演算子をサポートしている型のことです。
type Ordered interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		string
}
```

実際には、この制約は、関数や型の定義で使用できるように、
新しい標準ライブラリパッケージである`constraints`で定義され、
エクスポートされる可能性が高いでしょう。

この制約が与えられると、この関数を書くことができます。

```Go
// Smallestはスライス内の最小の要素を返します。
// スライスが空の場合はパニックになります。
func Smallest(type T constraints.Ordered)(s []T) T {
	r := s[0] // スライスが空だとpanicが起こる
	for _, v := range s[1:] {
		if v < r {
			r = v
		}
	}
	return r
}
```

#### 制約内の比較可能な型

先ほど、演算子は言語で事前に宣言された型に対してのみ使用できるというルールには、2つの例外があることを述べました。
例外は `==` と `!=` で、これは構造体、配列、およびインタフェース型に対して許可されています。
これらは十分に便利なので、同等の型を受け付ける制約を書けるようにしたいところです。

これを実現するために、新しい事前宣言型制約`comparable`を導入します。
`comparable`制約を持つ型パラメータは、任意の比較可能な型を型の引数として受け入れます。
これにより、その型パラメータの値に対して `==` や `!=` を使用することができます。

例えば、この関数は、任意の比較可能な型でインスタンス化することができます。

```Go
// Indexは、sの中のxのインデックスを返し、見つからなかった場合は-1を返します。
func Index(type T comparable)(s []T, x T) int {
	for i, v := range s {
    // vとxはT型であり、これは同等の制約を持っているので、
    // ここでは==を使うことができます
		if v == x {
			return i
		}
	}
	return -1
}
```

すべての制約と同様に`comparable`はインタフェース型なので、
制約として使われる別のインタフェース型に埋め込むことができます。

```Go
// ComparableHasherは、すべての比較可能な型をHashメソッドでマッチさせる型制約です。
type ComparableHasher interface {
	comparable
	Hash() uintptr
}
```

制約 `ComparableHasher` は比較可能な任意の型で実装されており、`Hash() uintptr` メソッドを持ちます。
制約として `ComparableHasher` を用いるジェネリクス関数は、その型の値を比較することができ、`Hash` メソッドを呼び出すことができます。

#### インターフェース型の型リスト


型リストを持つインタフェース型は、型パラメータに対する制約としてのみ使用することができます。
通常のインタフェース型としては使用できません。
予め宣言されたインタフェース型`comparable`も同様です。

この制限は将来の言語バージョンでは解除されるかもしれません。
型リストを持つインターフェイス型は、値 `nil` を持つことができるものではあるが、和型の一形態として有用であるかもしれません。
下位の型ではなく同一の型でマッチするためには、何らかの代替構文が必要になるでしょう。
今のところ、これは許可されていません。

### 関数引数の型推論

多くの場合、型の引数を持つ関数を呼び出す際には、
型推論を使用することで、 型の引数を明示的に書き出す必要がなくなります。

単純な`Print`関数の呼び出しの[例題](#型パラメータ)を振り返りましょう。

```Go
Print(int)([]int{1, 2, 3})
```

関数呼び出しの型引数`int`は、非型引数の型から推測することができます。

これは、すべての関数の型パラメータが関数の非型引数の型に使用されている場合にのみ可能です。
関数の結果パラメータの型にのみ使用される、
または関数のボディにのみ使用される型パラメータがある場合、
型を推論するための値がないため、
我々のアルゴリズムは関数の型引数を推論しません。

関数の型引数が推測できる場合、言語は型の統一を使用します。
呼び出し側には実際の非型引数の型のリストがあり、`Print` の例では単に `[]int` です。
関数側には、関数の非型パラメータの型のリストがあり、`Print` の場合は `[]T` です。
リストの中から、関数側が型パラメータを使わないそれぞれの引数を破棄します。
そして、残りの引数の型を統一しなければなりません。

型の統一は2パスのアルゴリズムです。
最初のパスでは、呼び出し側の型なし定数と関数定義の対応する型を無視します。

そして、リスト内の対応する型を比較します。
これらの構造は同一でなければなりませんが、
関数側の型パラメータが、
その型パラメータが発生した時点で呼び出し側に現れる型と一致することを除いては、
同じ構造でなければなりません。
関数側で同じ型パラメータが複数回出現する場合、
呼び出し側では複数の引数の型と一致します。
これらの呼び出し側の型は同一でなければならず、
そうでない場合は型の統一に失敗し、
エラーが報告されます。

最初のパスの後、
呼び出し側で型指定されていない定数がないかどうかをチェックします。
型指定されていない定数がない場合、
または対応する関数型の型パラメータが他の入力型と一致している場合、
型の統一が完了します。

そうでなければ、2回目のパスでは、
対応する関数型がまだ設定されていない型なし定数について、[通常の方法](https://golang.org/ref/spec#Constants)で型なし定数のデフォルト型を決定します。
そして，再び型統合アルゴリズムを実行します。

この例では

```Go
s1 := []int{1, 2, 3}
Print(s1)
```

`[]int` と `[]T` を比較し、`T` を `int` にマッチさせて終わりです。
単一の型パラメータ `T` は `int` であるため、`Print` の呼び出しは実際には `Print(int)` の呼び出しであると推論できます。

より複雑な例として、以下を考えてみましょう。

```Go
// Mapはスライスsの各要素に対して関数fを呼び出します。
// 結果の新しいスライスを返します。
func Map(type F, T)(s []F, f func(F) T) []T {
	r := make([]T, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}
```

2つの型パラメータ `F` と `T` はどちらも入力パラメータとして用いられるので、型推論が可能です。
呼び出しでは下記のようになります。

```Go
strs := Map([]int{1, 2, 3}, strconv.Itoa)
```

`[]int` と `[]F` に統一し、`F` と `int` をマッチングさせます。
型は`func(int) string`である`strconv.Itoa`の型を`func(F) T`に統一し、`F`は`int`に、`T`は`string`にマッチします。
型パラメータ`F`は2回マッチし、2回とも`int`とマッチする。
統一に成功したので、`Map`と書かれた呼び出しは`Map(int, string)`の呼び出しになります。

型なし定数ルールが有効であることを確認するには、次のように考えてみてください。

```Go
// NewPairは、同じ型の値のペアを返します。
func NewPair(type F)(f1, f2 F) *Pair(F) { ... }
```

呼び出しの `NewPair(1, 2)` では、両方の引数は型なし定数なので、最初のパスでは両方とも無視されます。
統一するものは何もありません。
最初のパスの後も2つの型なし定数が残っています。
両方ともデフォルトの型 `int` に設定されています。
型の統一パスの2回目の実行では `F` が `int` に統一されるので、最終的な呼び出しは `NewPair(int)(1, 2)` となります。

`NewPair(1, int64(2))`の呼び出しでは、最初の引数は型なしの定数なので、最初のパスでは無視します。
次に、`int64`を`F`で統一します。
この時点で型なし定数に対応する型パラメータは完全に決定されているので、最終的な呼び出しは`NewPair(int64)(1, int64(2))`である。

`NewPair(1, 2.5)`の呼び出しでは、引数は両方とも型なし定数なので、2回目のパスに移る。
今回は最初の定数を`int`に、2番目の定数を`float64`に設定します。
次に`F`を`int`と`float64`の両方で統一しようとすると、統一に失敗してコンパイルエラーとなります。

型推論は制約を無視して行われることに注意してください。
まず、型推論を用いて関数に用いる型引数を決定し、それが成功した場合、その型引数が制約を実装しているかどうかをチェックします（もしあれば）。

型推論が成功した後も、関数呼び出しの場合と同様に、コンパイラは引数がパラメータに代入できるかどうかをチェックしなければならないことに注意してください。

(注意: 型推論は便利な機能です。 重要な機能であると考えていますが、
これは何もデザインに機能性を持たせ，それを使用する上での利便性のみを考慮したものではありません。
最初の実装からそれを省略して、それが必要と思われるかどうかを確認することは可能でしょう。
そうは言っても、この機能は追加の構文を必要とせず、より読みやすいコードを生成します。)

### 制約の中で自分自身を参照する型を使用する

ジェネリクス関数では、引数が型そのものであるメソッドで型の引数を要求することが便利です。
例えば、これは比較メソッドで自然に発生します。
(ここでは演算子ではなくメソッドの話をしていることに注意してください。)
目的の値が見つかったかどうかを調べるために`Equal`メソッドを使う`Index`メソッドを書きたいとしましょう。
このように書きたいとします。

```Go
// indexは、sの中のeのインデックスを返します。
func Index(type T Equaler)(s []T, e T) int {
	for i, v := range s {
		if e.Equal(v) {
			return i
		}
	}
	return -1
}
```

`Equaler`制約を書くためには、渡される型引数を参照できる制約を書かなければなりません。
これを直接行う方法はありませんが、できることは型引数を使うインタフェース型を書くことです。

```Go
// Equaler is a type constraint for types with an Equal method.
type Equaler(type T) interface {
	Equal(T) bool
}
```

これを実現するために、`Index`は`T`を型引数として`Equaler`に渡します。
このルールは、型制約が単一の型パラメータを持ち、
それが明示的な型引数を持たずに関数の型パラメータリストで使われている場合、
型引数は制約を受ける型パラメータであるというものです。
つまり、上述の`Index`の定義では、制約`Equaler`は`Equaler(T)`として扱われます。

このバージョンの`Index`は、ここで定義されている`equalInt`のような型と一緒に使われます。

```Go
// equalIntは、Equalerを実装したintのバージョンです。
type equalInt int

// Equalメソッドは、equalIntにEqualer制約を実装させます。
func (a equalInt) Equal(b equalInt) bool { return a == b }

// indexEqualIntsは、sの中のeのインデックスを返します。
func indexEqualInt(s []equalInt, e equalInt) int {
	return Index(equalInt)(s, e)
}
```

この例では、`Index`に`equalInt`を渡すときに、`equalInt`が`Equaler`という制約を実装しているかどうかを調べます。
`Equaler`は型パラメータを持っているので、`Index`の型引数として`equalInt`を`Equaler`に渡します。
制約は`Equaler(equalInt)`であり、これはメソッド`Equal(equalInt) bool`を持つ任意の型で満たされます。
`equalInt`型には`equalInt`型のパラメータを受け付けるメソッド`Equal`があるので、すべてがうまくいき、コンパイルは成功します。

### 型パラメータの相互参照

単一の型パラメータ・リスト内では、制約は他の型パラメータを参照することができ、同じリスト内で後から宣言された型パラメータも参照することができます。
(型パラメータのスコープは、パラメータ・リストの`type`キーワードから始まり、それを囲む関数または型宣言の最後まで拡張されます。)

例えば、グラフを扱うジェネリクスアルゴリズムを含むジェネリクスグラフパッケージを考えてみましょう。
このアルゴリズムでは、`Node`と`Edge`の2つの型が使われます。
`Node`は`Edges() []Edge`というメソッドを持つことが期待される。
`Edge`は`Nodes() (Node, Node)`というメソッドを持つことが期待される。
グラフは`[]ノード`として表現することができる。

この単純な表現だけで、最短経路を求めるなどのグラフアルゴリズムを実装できます。

```Go
package graph

// NodeConstraintはグラフノードの型制約です。
// ノードは、このノードに接続するEdgeを返すEdgesメソッドを持っていなければなりません。
type NodeConstraint(type Edge) interface {
	Edges() []Edge
}

// EdgeConstraintは、グラフエッジの型制約です。
// このエッジが接続する2つのNodeを返すNodesメソッドを持たなければなりません。
type EdgeConstraint(type Node) interface {
	Nodes() (from, to Node)
}

// グラフとは、ノードとエッジで構成されたグラフのことです。
type Graph(type Node NodeConstraint(Edge), Edge EdgeConstraint(Node)) struct { ... }

// Newは、ノードのリストを与えられた新しいグラフを返します。
func New(
	type Node NodeConstraint(Edge), Edge EdgeConstraint(Node)) (
	nodes []Node) *Graph(Node, Edge) {
	...
}

// ShortestPathは、2つのノード間の最短パスを、エッジのリストとして返します。
func (g *Graph(Node, Edge)) ShortestPath(from, to Node) []Edge { ... }
```

ここには多くの型引数とインスタンス化があります。
`Graph`の`Node`に対する制約では，`NodeConstraint`の型制約に渡される`Edge`は，`Graph`の2番目の型パラメータです。
これは`NodeConstraint`のインスタンスを`Edge`という型パラメータで生成しているので，
`Node`は`Edge`のスライスを返すメソッド`Edges`を持たなければならないことがわかります．
同じことが`Edge`の制約にも当てはまり、同じ型のパラメータと制約が関数`New`にも繰り返されています。
これが単純だと主張しているのではなく、可能だと主張しているのです。

一見するとインターフェース型の典型的な使い方のように見えるかもしれませんが、
`Node`と`Edge`は特定のメソッドを持つ非インターフェース型です。
`graph.Graph`を使うためには、`Node`と`Edge`の型引数には、
あるパターンに従ったメソッドを定義しなければなりませんが、
実際にはインターフェース型を使う必要はありません。。
特に、これらのメソッドはインタフェース型を返さない。

例えば、他のパッケージでの型の定義を考えてみましょう。

```Go
// Vertexはグラフのノードです。
type Vertex struct { ... }

// Edgesは、vに接続されたエッジを返します。
func (v *Vertex) Edges() []*FromTo { ... }

// FromToはグラフ内の辺です。
type FromTo struct { ... }

// Nodes は ft が接続しているノードを返します。
func (ft *FromTo) Nodes() (*Vertex, *Vertex) { ... }
```

ここにはインターフェイスの型はありませんが
型引数 `*Vertex` と `*FromTo` を用いて `graph.Graph` を作成します。

```Go
var g = graph.New(*Vertex, *FromTo)([]*Vertex{ ... })
```

`*Vertex`と`*FromTo`はインタフェース型ではありませんが、一緒に使うと`graph.Graph`の制約を実装するメソッドを定義します。
なお、`Vertex`と`FromTo`は制約を実装していないので、`graph.New`にはプレーンな`Vertex`と`FromTo`を渡すことはできません。
`Edges`と`Nodes`のメソッドはポインタ型`*Vertex`と`*FromTo`で定義されており、`Vertex`と`FromTo`の型には何のメソッドもありません。

一般的なインターフェース型を制約として利用する場合、
まず、型パラメータリストで与えられた型引数を用いてその型をインスタンス化し、
対応する型引数をインスタンス化された制約と比較します。
この例では、`graph.New`の`Node`型の引数には`NodeConstraint(Edge)`という制約があります。
この例では、`graph.New`の`Node`型の引数に`*Vertex`、`Edge`型の引数に`*FromTo`を指定して`graph.New`を呼び出すと、
`Node`の制約を確認するために、コンパイラは`NodeConstraint`のインスタンスを`*FromTo`という型の引数で生成します。
この場合、`Node`が`Edges() []*FromTo`というメソッドを持つことが要求され、コンパイラは`*Vertex`がその制約を満たすことを確認します。

また、`Node`や`Edge`は必ずしもインタフェース型を使ってインスタンス化する必要はないが、インタフェース型を使っても構いません。

```Go
type NodeInterface interface { Edges() []EdgeInterface }
type EdgeInterface interface { Nodes() (NodeInterface, NodeInterface) }
```

型制約を実装しているので、`graph.Graph`のインスタンスに`NodeInterface`と`EdgeInterface`という型を与えることができます。
この方法で型をインスタンス化する理由はあまりありませんが、許可されています。

型パラメータが他の型パラメータを参照することができるということは、重要な点を示しています。
Goにジェネリクスを追加しようとする場合、
コンパイラが確認できる方法で互いに参照する複数の型引数を持つジェネリクスコードをインスタンス化できることが必要条件となります。

### ポインタメソッド

型の引数`A`がポインタ型`*A`に定義されたメソッドを持っている場合にのみ、
ジェネリクス関数が期待通りに動作する場合があります。
これは、値を変更するメソッドを呼び出すことを期待してジェネリクス関数を書く場合に起こります。

この例では、文字列に基づいて値を初期化する`Set(string)`メソッドを持つ`T`型を想定した関数を考えてみましょう。

```Go
// Setterは、文字列から値を設定するSetメソッドを実装することを型に要求する型制約です。
type Setter interface {
	Set(string)
}

// FromStringsは文字列のスライスを取り、Tのスライスを返し、
// Setメソッドを呼び出してそれぞれの戻り値を設定します。
//
// Tは結果パラメータにのみ使用されるため，
// この関数を呼び出すと型推論が機能しないことに注意してください．
// 型の引数は、呼び出し元で明示的に渡さなければなりません。
//
// この例はコンパイルされていますが、希望通りには動作しません。
func FromStrings(type T Setter)(s []string) []T {
	result := make([]T, len(s))
	for i, v := range s {
		result[i].Set(v)
	}
	return result
}
```

では、別のパッケージのコードを見てみましょう（この例は無効です）。

```Go
// Settableは文字列から設定できる整数型です。
type Settable int

// Setは、文字列から*pの値を設定します。
func (p *Settable) Set(s string) {
	i, _ := strconv.Atoi(s) // real code should not ignore the error
	*p = Settable(i)
}

func F() {
	// 無効
	nums := FromStrings(Settable)([]string{"1", "2"})
	// ここではnumsを[]Settable{1, 2}にします。
	...
}
```

目標は`FromStrings`を用いて`[]Settable`型のスライスを取得することです。
残念ながら、この例は有効ではないのでコンパイルできません。

問題は、`FromStrings`は`Set(string)`メソッドを持つ型を必要とすることです。
関数`F`は`FromStrings`を`Settable`でインスタンス化しようとしていますが、
`Settable`には`Set`メソッドがありません。
`Set`メソッドを持つ型は`*Settable`である。

そこで、`F`を書き換えて`*Settable`を使うようにしましょう。

```Go
func F() {
	/ コンパイルはするが、思うように動作しない。
	/ これは、Setメソッドを呼び出すときに実行時にパニックになります。
	nums := FromStrings(*Settable)([]string{"1", "2"})
	...
}
```

これでコンパイルできますが、残念ながら実行時にパニックになります。
問題は`FromStrings`が`[]T`型のスライスを生成することです。
`FromStrings`が`*Settable`でインスタンス化された場合、これは`[]*Settable`型のスライスを意味します。
`FromStrings`が`result[i].Set(v)`を呼び出すと、`result[i]`に格納されているポインタを`Set`メソッドに渡します。
このポインタは`nil`です。
`Settable.Set`メソッドは`nil`のレシーバで呼び出され、`nil`の参照解除エラーでパニックを起こすことになります。

必要なのは、`Settable`型を引数に取りながらポインタメソッドを呼び出すことができるような`FromStrings`の書き方です。
繰り返しになりますが、`Settable`には`Set`メソッドがないので、`Settable`は使えませんし、`*Settable`も使えません。

これでは`Settable`型と`*Settable`型のスライスを作成することができないからです。

```Go
package from

// Setter2は、文字列から値を設定するSetメソッドを実装することを要求する型制約であり、
// 型パラメータへのポインタであることも要求します。
type Setter2(type B) interface {
	Set(string)
	type *B
}

// FromStrings2は文字列のスライスを取り、Tのスライスを返し、
// Setメソッドを呼び出してそれぞれの戻り値を設定します。
//
// 2つの異なる型のパラメータを使用して
/ 、T型のスライスを返し、*Tのメソッドを呼び出すことができます。
// Setter2制約により、PTがTへのポインタであることが保証されます。
func FromStrings2(type T interface{}, PT Setter2(T))(s []string) []T {
	result := make([]T, len(s))
	for i, v := range s {
		// &result[i]の型はSetter2の型リストにある*Tなので、
		// PTに変換します。
		p := PT(&result[i])
		// PTにはSetメソッドがあります。
		p.Set(v)
	}
	return result
}
```

このように`FromStrings2`を呼び出します。

```Go
func F2() {
	// FromStrings2は2つの型のパラメータを取ります。
	// 2番目のパラメータは1番目のパラメータへのポインタでなければなりません。
	// 設定可能なのは上記の通りです。
	nums := FromStrings2(Settable, *Settable)([]string{"1", "2"})
	// これでnumsは[]Settable{1, 2}になりました。
	...
}
```

このアプローチは期待通りに動作しますが、厄介です。
これは、2つの型引数を渡すことで`FromStrings2`の問題を回避するために`F2`を強制するものです。
2番目の型引数は1番目の型引数へのポインタであることが要求されます。
これは、合理的に単純なケースであるはずなのに複雑な要件です。

別のアプローチとしては、メソッドを呼び出すのではなく関数を渡すという方法もあります。

```Go
// FromStrings3は文字列のスライスを取り、Tのスライスを返し、
// 返された値をそれぞれ設定するためにset関数を呼び出します。
func FromStrings3(type T)(s []string, set func(*T, string)) []T {
	results := make([]T, len(s))
	for i, v := range s {
		set(&results[i], v)
	}
	return results
}
```

このように`Strings3`と呼ぶことができます。

```Go
func F3() {
	// FromStrings3は値を設定するための関数を取ります。
	// 設定可能なのは上記の通りです。
	nums := FromStrings3(Settable)([]string{"1", "2"},
		func(p *Settable, s string) { p.Set(s) })
	// これでnumsは[]Settable{1, 2}になりました。
}
```

このアプローチも期待通りに動作しますが、厄介です。
呼び出し元は`Set`メソッドを呼び出すためだけに関数を渡さなければなりません。
これはジェネリクスを使うときに避けたい陳腐なコードです。

これらのアプローチは厄介ですが、うまくいきます。
それは、型パラメータ自体ではなく、
型パラメータへのポインタに対する制約を表現する方法です。
この方法は、型パラメータをポインタ型であるかのように書くことです。`(type *T Constraint)`.

型パラメータのリストで`T`の代わりに`*T`を書くと、2つのことが変わります。
呼び出し元の型の引数が`A`で、制約が`Constraint`であるとします(この構文は制約なしでも使えますが、そうする理由はありません。)

最初に変わるのは、`Constraint`が`A`ではなく`*A`に適用されることです。
つまり、`*A`は`Constraint`を実装しなければなりません。
`A`が`Constraint`を実装しても構いませんが、
`*A`が`Constraint`を実装していることが条件となります。
もし`Constraint`が何らかのメソッドを持つ場合、
これは`A`がポインタ型であってはならないことを意味していることに注意してください。

2つ目の変更点は、関数本体内で`Constraint`のメソッドがポインタ型であるかのように扱われることです。
これらのメソッドは`*T`型の値か`T`型のアドレス指定可能な値に対してのみ呼び出すことができます。

```Go
// FromStringsは文字列のスライスを取り、Tのスライスを返し、
// Setメソッドを呼び出してそれぞれの戻り値を設定します。
//
// ここでは*Tと書きますが、これは型引数Aが与えられた場合、
// ポインタ型*AはSetterを実装しなければならないことを意味しています。
//
// Tは結果パラメータにのみ使用されるため，
// この関数を呼び出すと型推論が機能しないことに注意してください。
// 型の引数は呼び出し元で明示的に渡さなければなりません。
func FromStrings(type *T Setter)(s []string) []T {
	result := make([]T, len(s))
	for i, v := range s {
		// result[i]はT型のアドレス指定可能な値なので、Setを呼んでも問題ありません。
		result[i].Set(v)
	}
	return result
}
```

ここでも`*T`を使うと、型の引数`A`が与えられると、
型`*A`は`Setter`という制約を実装しなければならないことを意味します。
この場合、`Set`は`*A`のメソッドセットの中になければなりません。
`FromStrings`の中で`*T`を使うということは、
`Set`メソッドは`T`型のアドレス指定可能な値に対してのみ呼び出すことができるということを意味します。

これを次のように使うことができます。

```Go
func F() {
	// FromStringsを書き換えたことで、これでOKになりました。
	// *SettableはSetterを実装しています。
	nums := from.Strings(Settable)([]string{"1", "2"})
	// ここでnumsは[]Settable{1, 2}です。
	...
}
```

はっきりさせておきますが、`type *T Setter`を使っても`Set`メソッドはポインタメソッドでなければならないという意味ではありません。
`Set`はまだ値メソッドである可能性があります。
すべての値メソッドはポインタ型のメソッドセットに含まれているからです。
この例では、`Set`を値メソッドとして記述できる場合にのみ意味があります。

### 無名関数パラメータ型としてのジェネリクス型の使用

インスタンス化された型を無名関数のパラメータ型として解析すると、解析が曖昧になります。

```Go
var f func(x(T))
```

この例では，この関数がインスタンス化された型 `x(T)` の単一の無名パラメータを持っているのか，それとも `(T)` 型の名前付きパラメータ `x` (括弧付きで書かれています)なのかはわかりません。

インスタンス化された型`x(T)`の名前のないパラメータであることを意味する前者であることを期待します。
これは現在の言語では後者を意味しますが、実際には下位互換性はありません。
しかし、現在のところ、gofmtプログラムは`func(x(T))`を`func(x T)`に書き換えているので、`func(x(T))`はプレーンなGoコードでは非常に珍しい。

そこで、`func(x(T))`が`x(T)`型の単一のパラメータを意味するように言語を変更することを提案する。
これは既存のプログラムを破壊する可能性がありますが、修正は単純にgofmtを実行することになります。
これは、`func(x(T))`を書き、gofmtを使わず、関数のパラメータと同じ名前で括弧付きの型を持つジェネリクス型`x`を導入するプログラムの意味を変える可能性があります。
このようなプログラムは非常に稀だと考えています。

それでも、これはリスクであり、リスクが大きすぎると思われる場合には、この変更を避けることができます。

### 型パラメータの値はボックス化されない

現在のGoの実装では、インターフェースの値は常にポインタを保持しています。
ポインタではない値をインタフェース変数に入れると、値は_ボックス化(boxed)_になります。
つまり、実際の値はヒープやスタックのどこか別の場所に保存され、インターフェース値はその場所へのポインタを保持しているということです。

この設計では、ジェネリクス型の値はボックス化されません。
例えば、先ほどの`from.Strings`の例を見てみましょう。
これが`Settable`型でインスタンス化されると、`[]Settable`型の値を返します。
例えば、次のように書くことができます。

```Go
// Settableは文字列から設定できる整数型です。
type Settable int

// Setは、文字列から*pの値を設定します。
func (p *Settable) Set(s string) (err error) {
	// 同上
}

func F() {
  // numsの型は[]Settableです。
	nums, err := from.Strings(Settable)([]string{"1", "2"})
	if err != nil { ... }
	// 設定可能なものは、直接intに変換することができます。
	// 最初に1がセットされます。
	first := int(nums[0])
	...
}
```

型`Settable`で`from.Strings`を呼び出すと、`[]Settable`が返ってきます(そしてエラー)。
このスライスの要素は`Settable`の値になります。
たとえジェネリクス関数によって作成・設定されたものであっても、それらはボックス化されることはありません。

同様に、ジェネリクス型がインスタンス化された場合も、コンポーネントとして期待される型を持つことになります。

```Go
type Pair(type F1, F2) struct {
	first  F1
	second F2
}
```

これがインスタンス化されると、フィールドはボックス化されず、予期せぬメモリ割り当てが発生しなくなります。
型`Pair(int, string)`は`struct { first int; second string }`に変換可能です。

### 型リストの詳細

ここで、型リストの話に戻ります。
あまり重要ではありませんが注意すべき点がいくつかあります。
これらは追加の規則や概念ではなく、型リストがどのように動作するかの結果です。

#### 制約内の型リストとメソッドの両方

制約は、型リストとメソッドの両方を使用することができます。

```Go
// StringableSignedIntegerは
//  1) 符号付き整数型として定義されている型
//  2) Stringメソッドを持つ型の両方にマッチする型制約
// です。
type StringableSignedInteger interface {
	type int, int8, int16, int32, int64
	String() string
}
```

この制約は、`String() string`メソッドを持つことを条件に、
基底型がリストアップされた型のいずれかである任意の型を許可します。
`StringableSignedInteger`制約は明示的に`int`をリストアップしていますが、
`int`は`String`メソッドを持たないため、`int`自体は型の引数としては許可されません。
許可される型引数の例としては、`MyInt`があります。

```Go
// MyInt is a stringable int.
// MyIntは文字列可能なintです。
type MyInt int

// String メソッドは、mi の文字列表現を返します。
func (mi MyInt) String() string {
	return fmt.Sprintf("MyInt(%d)", mi)
}
```

#### 制約の複合型

制約内の型は、型リテラルである場合があります。

```Go
type byteseq interface {
	type string, []byte
}
```

通常のルールが適用されます。この制約の型の引数には`string`や`[]byte`、あるいはこれらの型のいずれかで定義された型を指定することができます。

この制約を持つジェネリクス関数は、`string`と`[]byte`の両方の型で許可されている操作を使用することができます。

```Go
// Joinは第1引数の要素を連結して1つの値を作成します。
// Joinはstringと[]byteで動作します。
func Join(type T byteseq)(a []T, sep T) (ret T) {
	if len(a) == 0 {
		// resultパラメータをゼロ値として使用します。
		// 問題セクションのゼロ値の説明を参照してください。
		return ret
	}
	if len(a) == 1 {
		// a[0]はstringか[]byteであることがわかっています。
		// stringまたは[]byteを[]byteに追加することができます。
		// []byteを生成します。この[]byteを[]byteかstringに変換することができます。
		return T(append([]byte(nil), a[0]...))
	}
  // stringと[]byteの両方でlenを呼び出すことができるので、sepでlenを呼び出すことができます。
	n := len(sep) * (len(a) - 1)
	for _, v := range a {
		// stringや[]byteに対してlenを呼び出す場合もあります。
		n += len(v)
	}

	b := make([]byte, n)
	// stringか[]byteのどちらかの引数で[]byteへのコピーを呼び出すことができます。
	bp := copy(b, a[0])
	for _, s := range a[1:] {
		bp += copy(b[bp:], sep)
		bp += copy(b[bp:], s)
	}
	// 上記のように、bを[]byteまたはstringに変換することができます。
	return T(b)
}
```

#### 型リストの型パラメータ

制約の型リテラルは制約の型パラメータを参照することができます。
この例では、ジェネリクス関数`Map`は2つの型パラメータを取る。
最初の型パラメータは、2番目の型パラメータのスライスである基底型を持つことが要求されます。
第２のスライスパラメータには制約はありません。

```Go
// SliceConstraintは、型パラメータのスライスにマッチする型制約です。
type SliceConstraint(type T) interface {
	type []T
}

// Map は、ある要素の型と変換関数のスライスを取り、各要素に適用された関数のスライスを返します。
// Map は、定義された型であっても、スライスの引数と同じ型のスライスを返します。
func Map(type S SliceConstraint(E), E interface{})(s S, f func(E) E) S {
	r := make(S, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}

MySliceはシンプルに定義された型です。
type MySlice []int

// DoubleMySliceはMySlice型の値を取り、
// 各要素の値が2倍になった新しいMySliceの値を返します。
func DoubleMySlice(s MySlice) MySlice {
	v := Map(MySlice, int)(s, func(e int) int { return 2 * e })
  // ここでvはMySlice型であって[]int型ではありません。
	return v
}
```

#### 型変換

`From`と`To`の2つの型パラメータを持つ関数において、
`From`の制約で受け入れられるすべての型を`To`の制約で受け入れられるすべての型に変換できる場合、
`From`の型の値を`To`の型の値に変換することができます。
どちらかの型パラメータが型を受け付けない場合、型変換は許可されません。

これは、ジェネリクス関数は型リストに記載されているすべての型で許可されている操作を使用できるという一般的なルールの結果です。

例えば、以下のようになります。

```Go
type integer interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr
}

func Convert(type To, From integer)(from From) To {
	to := To(from)
	if From(to) != from {
		panic("範囲外変換")
	}
	return to
}
```

Goはすべての整数型を他のすべての整数型に変換することを許可しているので、`Convert`での型変換は許可されています。

#### 非型定数

関数の中には、型なし定数を使用するものがあります。
型指定されていない定数は、
型パラメータの制約で受け入れられるすべての型で許可されている場合、
ある型パラメータの値で許可されます。

型変換と同様に、
これは、型リストに記載されているすべての型で、
許可されている操作をジェネリクス関数が使用できるという一般的なルールの結果です。

```Go
type integer interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr
}

func Add10(type T integer)(s []T) {
	for i, v := range s {
		s[i] = v + 10 // OK: 10 は任意の整数型に変換できます。
	}
}

// この関数は無効です。
func Add1024(type T integer)(s []T) {
	for i, v := range s {
		s[i] = v + 1024 // 無効: 1024 は int8/uint8 では許可されません。
	}
}
```

#### 型リストの複合型に関する注意事項

型リストでの複合型の使用を完全に理解しているとは言えません。
例えば、次のようなことを考えてみましょう。

```Go
type structField interface {
	type struct { a int; x int },
		struct { b int; x float64 },
		struct { c int; x uint64 }
}

func IncrementX(type T structField)(p *T) {
	v := p.x
	v++
	p.x = v
}
```

この制約は、`IncrementX`の型パラメータに対するもので、
すべての有効な型の引数は、ある数値型のフィールド`x` を持つ構造体であることを意味します。
したがって、
`IncrementX`は有効な関数であると言いたくなります。
これは、 `v`の型が型パラメータに基づく型であり、
`interface { type int, float64, uint64 }`という暗黙の制約があることを意味します。
これはかなり複雑になる可能性があり、
理解できない詳細があるかもしれません。

初期の実装では，型リストの複合型は全くサポートしていないかもしれませんが，
これでは先ほどの `Join` の例は無効になってしまいます．

#### 埋め込み制約の型リスト

制約が別の制約を埋め込む場合、最終的な制約の型リストは、
関係するすべての型リストの交点となります。
複数の埋め込み型がある場合、
交差は、どの型の引数もすべての埋め込み型の要件を満たさなければならないという特性を保持します。

```Go
// Addableは+演算子をサポートする型です。
type Addable interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64, complex64, complex128,
		string
}

// Byteseqは、stringまたは[]byteのいずれかのバイト列です。
type Byteseq interface {
	type string, []byte
}

// AddableByteseqは+をサポートするバイト列です。
// これは、すべての型がAddableとByteseqの両方に対応しています。
// つまり、string型だけです。
type AddableByteseq interface {
	Addable
	Byteseq
}
```

#### 型リストの一般的な注意事項

制約の中で明示的に型を列挙するのは厄介に思われるかもしれませんが、
呼び出し側でどの型引数が許可されているかと、
ジェネリクス関数でどの操作が許可されているかの両方が明確になっています。

演算子メソッドをサポートするように言語が変更された場合（現在のところそのような計画はありません）、
制約は他の種類のメソッドと同様に演算子メソッドを扱います。

予め宣言された型の数は常に限られており、それらの型がサポートする演算子の数も限られています。
将来の言語の変更によってこれらの事実が根本的に変わることはないので、このアプローチは引き続き有用です。

このアプローチはすべての演算子を扱おうとはしていません。
複合型に対してうまく機能するかどうかは明らかではありません。
予想されるのは、型の引数として複合型を要求するのではなく、
一般的な関数や型の宣言で複合型を使って処理されることです。
例えば、スライスにインデックスを追加するような関数は、
スライス要素の型`T`でパラメータ化され、
型`[]T`のパラメータや変数を使用することを期待しています。

上の `DoubleMySlice` の例で示されているように、このアプローチは、
複合型を受け入れて返すジェネリクス関数を宣言することを厄介にし、
引数型と同じ結果型を返したいと考えています。
定義された複合型は一般的ではありませんが、発生することはあります。
この厄介さがこのアプローチの弱点です。

### リフレクション

`reflect`パッケージを変更することは提案していません。
型や関数がインスタンス化されると、すべての型パラメータは通常のジェネリクス型になります。
インスタンス化された型の `reflect.Type` 値の `String` メソッドは、型の引数を括弧で囲んだ名前を返します。
例えば、`List(int)`のようになります。

非ジェネリクスコードがインスタンス化せずにジェネリクスコードを参照することは不可能なので、
インスタンス化されていないジェネリクス型や関数のリフレクション情報はありません。

### 実装

ラス・コックスは、ジェネリクスは遅いプログラム、遅いコンパイラ、遅い実行時間のいずれかを選択する必要があることを[指摘](https://research.swtch.com/generic)しています。

私たちは、この設計は異なる実装の選択を可能にすると考えています。
コードは型引数のセットごとに別々にコンパイルされるかもしれませんし、各型引数がメソッド呼び出しを伴うインターフェース型と同様に扱われるかのようにコンパイルされるかもしれませんし、その2つの組み合わせがあるかもしれません。

言い換えれば、この設計は、人々が遅いプログラムを選ぶことを止め、
遅いコンパイラ(型引数の各セットを別々にコンパイルする)か、
遅い実行時間(型引数の値に対する各操作にメソッド呼び出しを使用する)かを実装が決めることを許可します。

### 要約

このドキュメントは長くて詳細ですが、実際の設計はいくつかの主要なポイントに集約されます。

* 関数や型は型引数を持つことができ、これはオプションの制約を使って定義されたもので、インターフェース型です。
* 制約は、型の引数に必要なメソッドと許可される型を記述します。
* 制約は、型パラメータに対して許可されるメソッドと操作を記述します。
* 型推論では、型パラメータを持つ関数を呼び出す際に、型引数を省略することを許可することがよくあります。

このデザインは、`func F(x(T))`の意味の変更が提案されていることを除けば、完全に下位互換性があります。

このデザインは、必要以上に言語を複雑にすることなく、
Goでジェネリクスプログラミングをしたいという人々のニーズに応えていると考えています。

このデザインが言語に与える影響については、
長年の経験がなければ本当に知ることはできません。
とはいえ、以下にいくつかの推測を示します。

#### 複雑さ

Goの素晴らしい点の一つは、そのシンプルさです。
この設計は明らかに言語をより複雑にしています。

私たちは、優れたジェネリクスのコードを書くのではなく、
優れたジェネリクスのコードを読んでいる人にとっては、複雑さの増加は小さいと考えています。
当然のことながら、人々は型パラメータを宣言するための新しい構文を学ばなければなりません。
この新しい構文と、インターフェイスの型リストの新しいサポートが、このデザインの唯一の新しい構文構成です。
ジェネリクス関数内のコードは、以下の例にあるように、通常のGoコードのように読めます。
これは、`[]int`から`[]T`への簡単な移行です。
型パラメータ制約は、型を記述するための文書として効果的に機能します。

ほとんどのパッケージはジェネリクス型や関数を定義しないと予想されますが、
多くのパッケージは他の場所で定義されたジェネリクス型や関数を使用する可能性があります。
一般的なケースでは、ジェネリクス関数は非ジェネリクス関数と全く同じように動作します。
型推論は、型の引数を明示的に書き出す必要がないことを意味します。
型推論のルールは、型の引数が正しく推論されるか、呼び出しに失敗して
明示的な型パラメータを使用します。
型推論では、似ているが同一ではない2つの型の解決を試みずに型の同一性を使用します。

ジェネリクス型を使用するパッケージは、明示的な型引数を渡さなければなりません。
このための構文はよく知られています。
唯一の変更点は、引数を関数だけに渡すのではなく、型に渡すことです。

基本的に、私たちは設計上の驚きを避けようとしてきました。
これが成功したかどうかは時がたてばわかります。

#### 広播性

標準ライブラリにはいくつかの新しいパッケージが追加される予定です。
新しい`slices`パッケージは、既存のbytesやstringsパッケージと似たようなもので、任意の要素型のスライスに対して操作することができます。
新しい`maps`と`chans`パッケージは、現在各要素型に対して重複している単純なアルゴリズムを提供します。
`set`パッケージが追加されるかもしれません。

新しい`constraints`パッケージは、すべての整数型やすべての数値型を許可する制約などの標準的な制約を提供します。

`container/list`や`container/ring`のようなパッケージや`sync.Map`や`sync/atomic.Value`のような型は、
新しい名前か新しいバージョンのパッケージを使って、コンパイル時に型安全になるように更新されます。

`math`パッケージは、人気のある`Min`や`Max`関数のような、
すべての数値型のためのシンプルな標準アルゴリズムのセットを提供するように拡張されます。

また、`sort`パッケージにジェネリクス変数を追加するかもしれません。

新しい特別な目的のコンパイル時型安全コンテナ型が開発される可能性があります。

C++のSTLイテレータ型のようなアプローチが広く使われるようになることは期待していません。
Goでは、この種のアイデアはインターフェイス型を使用してより自然に表現されます。
C++の用語では、イテレータにインターフェイス型を使用することは、抽象化のペナルティがあると考えられます。
つまり、実行時の効率は、事実上すべてのコードをインライン化するC++のアプローチよりも低くなります。

コンテナの型が増えれば、標準的な`Iterator`インターフェイスを開発することになるかもしれません。
そうなると、言語を変更して`range`句で`Iterator`を使用するメカニズムを追加するように圧力をかけることになるかもしれません。
しかし、これは非常に憶測に基づいたものです。

#### 効率性

人々がジェネリクスコードにどのような種類の効率性を期待しているかは明らかではありません。

ジェネリクス型ではなく、ジェネリクス関数は、
おそらくインターフェースベースのアプローチを使ってコンパイルすることができます。
これは、関数が一度だけコンパイルされるという点で、
コンパイル時間を最適化しますが、実行時間のコストがかかります。

一般的な型は当然のことながら、
型の引数のセットごとに複数回コンパイルされることになります。
これは明らかにコンパイル時間のコストがかかりますが、
実行時間のコストは発生しないはずです。
コンパイラは、型パラメータに依存する各要素にアクセスするための特別なメソッドを使用して、
インターフェース型と同様にジェネリクス型を実装することもできます。

この分野で人々が何を期待しているかは経験だけが示すでしょう。

#### 見落とし

この設計は、ジェネリクスプログラミングの基本的な要件をカバーしていると考えています。
しかし、サポートされていないプログラミング構造がいくつかあります。

* 専門化されていません。
  特定の型の引数で動作するように設計されたジェネリクス関数の複数のバージョンを書く方法はありません。
* メタプログラミングがない。
  コンパイル時に実行されるコードを、
  実行時に実行されるコードを生成するために書く方法がありません。
* より高いレベルの抽象化がない。
  型引数を持つ関数を呼び出すかインスタンス化する以外に、
  型引数を持つ関数について語る方法がありません。
  一般的な型については、インスタンス化する以外の方法はありません。
* 一般的な型の記述がありません。
  ジェネリクス関数で演算子を使うために、
  制約は、型が持たなければならない特性を記述するのではなく、
  特定の型をリストアップしています。
  これは理解しやすいですが、時には制限されることもあります。
* 関数パラメータの共分散や逆分散はありません。
* 演算子メソッドはありません。
  コンパイル時に型安全なジェネリクスコンテナを書くことはできますが、
  それにアクセスできるのは通常のメソッドのみで、`c[k]`のような構文は使えません。
* カリーはありません。
  ヘルパー関数やラッパー型を使う以外に，
  型引数の一部だけを指定する方法はありません．
* 可変型の型パラメータがありません。
  これは，型パラメータと通常のパラメータの両方を異なる数だけ取る単一のジェネリクス関数を書くことを可能にします．
* アダプタがありません．
  例えば、`Equal` メソッドの代わりに `==` 演算子を定義したり、
  制約が実装されていない型引数をサポートするために使用できるアダプタを定義する方法はありません。
* 定数のような型を持たない値のパラメータ化は行いません。
  これは最も明らかに配列の場合に発生しますが，`type Matrix(type n int) [n][n]float64` と書いておくと便利な場合があります。
  また，要素のデフォルト値のように，コンテナ型に重要な値を指定しておくと便利な場合もあります．


#### 問題点

このデザインには、
より詳細な議論に値するいくつかの問題点があります。
これらの問題はデザイン全体に比べれば比較的軽微なものですが、
それでも完全なヒアリングと議論に値すると考えています。

##### ゼロ値

この設計では、型パラメータのゼロ値に対する単純な表現がありません。
例えば、ポインタを使用するオプション値のこの実装を考えてみましょう。

```Go
type Optional(type T) struct {
	p *T
}

func (o Optional(T)) Val() T {
	if o.p != nil {
		return *o.p
	}
	var zero T
	return zero
}
```

`o.p == nil`の場合、`T`の値を0にして返したいのですが、それを書く方法がありません。
`return nil`を書けたらいいのですが、`T`が例えば`int`の場合にはうまくいきません。
また、もちろん、`return nil`や`return 0`をサポートする制約を書く方法はありません。

いくつかのアプローチがあります。

* `var zero T`は既存のデザインで動作しますが、追加の文が必要です。
* `*new(T)`は暗号化されていますが、既存のデザインで動作します。
* 結果のみの場合は、結果パラメータに`_`という名前を付け、ゼロ値を返すために裸の`return`文を使用します。
* 一般的な型のゼロ値として `nil` を使用できるようにデザインを拡張しました (ただし、[issue 22729](https://golang.org/issue/22729) を参照してください)。
* 設計を拡張し、`T{}` (`T` は型パラメータ`T`) は型のゼロ値を示すようにしました。
* [issue19642](https://golang.org/issue/19642)で提案されているように、代入(`return`や関数呼び出しを含む)の右手に`_`を使用できるように言語を変更しました。
* [issue21182](https://golang.org/issue/21182)で提案されているように、結果型の値をゼロにするために`return ...`を使用することを許可するように言語を変更しました。

私たちは、ここで何をすべきかを決定する前に、
このデザインについてより多くの経験が必要であると感じています。

##### 括弧多すぎてだるい

型引数を持つ関数を呼び出すと、型引数が推論できない場合、型引数の追加リストが必要になります。
関数が関数を返してきて、それを呼び出すと、さらに多くの括弧を得ることになります。

```Go
	F(int, float64)(x, y)(s)
```

型の引数と正規の引数を分離するためにコロンを使用するなど、他の構文で実験を行いました。
現在のデザインが一番いいように思えますが、もっといいものができるかもしれません。

##### 定義された複合タイプ

[前述](#型リストの型パラメータ)のように、関数が引数として、基底型が複合型である定義済み型を取り、その結果として同じ定義済み型を返すためには、余分な型パラメータが必要となります。

例えば、この関数はスライスをまたいで関数をマッピングします。

```Go
// マップはsの各要素にfを適用し、結果を保持する新しいスライスを返します。
func Map(type T)(s []T, f func(T) T) []T {
	r := make([]T, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}
```

ただし、定義された型で呼び出された場合は、定義された型そのものではなく、その型の要素型のスライスを返します。

```Go
// MySliceは定義された型です。
type MySlice []int

// DoubleMySliceは、sの対応する要素の2倍の要素を持つ新しいMySliceを返します。
func DoubleMySlice(s MySlice) MySlice {
	s2 := Map(s, func(e int) int { return 2 * e })
	// ここでs2は[]int型であり，MySlice型ではありません．
	return MySlice(s2)
}
```

[前述](#型リストの型パラメータ)のように、これは`Map`に余分な型パラメータを使用し、
スライスと要素の型の間の必要な関係を記述する制約を使用することで回避できます。
これは動作しますが、厄介です。

##### 一致した宣言済み型の識別

この設計では、型の引数にマッチする基本的な型をテストする方法は提供されていません。
コードは、空のインターフェイス型に変換して、型アサーションや型スイッチを使うというやや厄介なアプローチで実際の型の引数をテストすることができます。
しかし、これでは実際の型の引数をテストすることができますが、これは基礎となる型とは異なります。

ここに違いを示す例があります。

```Go
type Float interface {
	type float32, float64
}

func NewtonSqrt(type T Float)(v T) T {
	var iterations int
	switch (interface{})(v).(type) {
	case float32:
		iterations = 4
	case float64:
		iterations = 5
	default:
		panic(fmt.Sprintf("unexpected type %T", v))
	}
	// コードは省略されています。
}

type MyFloat float32

var G = NewtonSqrt(MyFloat(64))
```

なぜなら、`NewtonSqrt`関数の`v`の型は`float32`や`float64`ではなく`MyFloat`になるからです。
この関数が実際にテストしたいのは`v`の型ではなく、
制約の中で`v`がマッチした型です．

これを処理する1つの方法として，型`T`の型スイッチを許可することが考えられますが，
この場合，型`T`は制約で定義された型に常にマッチします．
この種の型スイッチは、制約が明示的な型を列挙している場合にのみ許可され、
制約に列挙されている型のみがケースとして許可されます。

##### 収斂性を表現する方法がない

このデザインでは、2つの異なる型のパラメータ間の収束性を表現する方法がありません。
例えば、この関数を書く方法がありません。

```Go
// 値を src から dst にコピーし，変換しながらコピーします．
// コピーされた項目の数を返します．
// この実装は不正です。
func Copy(type T1, T2)(dst []T1, src []T2) int {
	for i, x := range src {
		if i > len(dst) {
			return i
		}
		dst[i] = T1(x) // 不正
	}
	return len(src)
}
```

型`T2`から型`T1`への変換は，どちらの型にも変換を許可する制約がないため，無効です。
さらに悪いことに、一般的にそのような制約を書く方法はありません。
`T1`と`T2`の両方が何らかの型リストを必要とするような特殊なケースでは，この関数は[型リストを用いた型変換](#型変換)で述べたように書くことができます。
しかし、例えば、`T1`がインタフェース型であり、`T2`がそのインタフェースを実装した型である場合の制約を書く方法はありません。

`T1`がインタフェース型である場合、空のインタフェース型への変換と型アサーションを用いて制約を書くことができますが、これはもちろんコンパイル時の型安全ではありません。

```Go
// 値を src から dst にコピーし，変換しながらコピーします．
// コピーされたアイテムの数を返します．
func Copy(type T1, T2)(dst []T1, src []T2) int {
	for i, x := range src {
		if i > len(dst) {
			return i
		}
		dst[i] = (interface{})(x).(T1)
	}
	return len(src)
}
```

##### パラメータ化されたメソッドがない

このドラフトデザインでは、メソッドに固有の型パラメータを宣言することを許可しません。
レシーバは型パラメータを持つことができますが、メソッドは型パラメータを追加しません。

Goでは、メソッドの主な役割の一つは、
型がインターフェースを実装することを許可することです。
パラメータ化されたメソッドがインターフェースを実装することを許可することが合理的に可能であるかどうかは明らかではありません。
例えば、パラメータ化されたメソッドのために明白な構文を使用している次のコードを考えてみましょう。
このコードでは、問題をより明確にするために複数のパッケージを使用しています。

```Go
package p1

// Sは、パラメータ化されたメソッドIdentityを持つ型です。
type S struct{}

// Identity は、どのようなタイプでも動作するシンプルなアイデンティティメソッドです。
func (S) Identity(type T)(v T) T { return v }

package p2

// HasIdentity は、パラメータ化された Identity メソッドで任意の型にマッチするインターフェイスです。
type HasIdentity interface {
	Identity(type T)(T) T
}

package p3

import "p2"

// CheckIdentity は、Identity メソッドが存在するかどうかをチェックします。
// この関数はパラメータ化されたメソッドを呼び出しますが、この関数自体はパラメータ化されていないことに注意してください。
func CheckIdentity(v interface{}) {
	if vi, ok := v.(p2.HasIdentity); ok {
		if got := vi.Identity(int)(0); got != 0 {
			panic(got)
		}
	}
}

package p4

import (
	"p1"
	"p3"
)

// CheckSIdentityは、CheckIdentityにSを渡します。
func CheckSIdentity() {
	p3.CheckIdentity(p1.S{})
}
```

この例では、パラメータ化されたメソッドを持つ型`S`とパラメータ化されたメソッドを持つ型`HasIdentity`があります。
`S`は`HasIdentity`を実装しています。
したがって、関数`p3.CheckIdentity`は`vi.Identity`を`int`引数で呼び出すことができ、
この例では`S.Identity(int)`の呼び出しとなります。
しかし、`package p3`は`p1.S`の型について何も知りません。
プログラムのどこか他の場所で`S.Identity`を呼び出すことはないかもしれません。
どこかで`S.Identity(int)`のインスタンスを作成する必要があるが、どうやって作成するのでしょうか。

リンク時にインスタンス化することもできるが、一般的な場合、
リンカがプログラムの完全な呼び出しグラフを走査して、
`CheckIdentity`に渡される可能性のある型のセットを決定する必要があります。
また、型反映が関与する一般的なケースでは、
型反映はユーザが入力した文字列に基づいてメソッドを検索する可能性があるため、このような探索だけでは十分ではありません。
そのため、一般的にリンカでパラメータ化されたメソッドをインスタンス化するには、
すべての可能な型の引数に対してすべてのパラメータ化されたメソッドをインスタンス化する必要があるかもしれません。

あるいは、実行時にインスタンス化することもできます。
一般的には、これはある種のJITを使用するか、ある種のリフレクションベースのアプローチを使用するためにコードをコンパイルすることを意味します。
どちらの方法も実装が非常に複雑で、実行時には驚くほど遅くなります。

あるいは、パラメータ化されたメソッドは実際にはインターフェイスを実装しないと決めることもできますが、
なぜメソッドが必要なのかはあまり明確ではありません。
インターフェースを無視すれば、
パラメータ化されたメソッドはパラメータ化された関数として実装することができます。

ですから、パラメータ化されたメソッドは一見明らかに便利そうに見えますが、
それが何を意味するのか、それをどのように実装するのかを決めなければならないでしょう。

#### 捨てられたアイデア

このデザインは完璧なものではなく、経験を積んでいく中でさらに洗練されていきます。
そうは言っても、すでに詳細に検討したアイデアはたくさんあります。
このセクションでは、反復的な議論を減らすために役立つことを期待して、
それらのアイデアのいくつかをリストアップします。
これらのアイデアはFAQの形で紹介されています。

##### コントラクト(contracts)はどうなったの？

型リストは、インターフェース型ではなく、コントラクトにのみ現れました。
しかし、多くの人は、コントラクトとインタフェース型の違いを理解するのに苦労しました。
また、コントラクトは対応するインタフェースの集合として表現できることが判明し、
コントラクトがなくても表現力が損なわれることはありませんでした。
そこで、インタフェース型だけを使うようにアプローチを単純化することにしました。

##### なぜ型リストではなくメソッドを使わないのですか？

_Type lists are weird._
_型リストはおかしい_
_なぜすべての演算子にメソッドを書かないのですか？_

演算子トークンをメソッド名として許可することも可能で、`+(T) T`のようなメソッドを導くことができます。
残念ながら、これだけでは十分ではありません。
シフト `<<(integer) T` やインデックス `[](integer) T` のような、単一のint型に限定されない演算に対して、任意の整数型にマッチする型を記述する機構が必要になります。
また、`==(T) untyped bool`のような演算には、型なしのboolean型が必要になります。
変換のような操作や，型の上に範囲があることを表現するために，新しい記法を導入する必要がありますが，これには新しい構文が必要になるでしょう．
型なし定数の有効な値を記述するメカニズムが必要になるでしょう。
`<(T) bool` をサポートすることは、ジェネリクス関数が `<=` を使用できることを意味し、
同様に `+(T) T` をサポートすることは、
関数が `++` を使用できることを意味するかどうかを検討しなければなりません。
このアプローチを実現することは可能かもしれませんが、一筋縄ではいきません。
このデザインで使われているアプローチはよりシンプルで、
1つの新しい構文構成(型リスト)と1つの新しい名前(`comparable`)だけに依存しています。

##### なぜパッケージに型パラメータを付けないのですか？

私たちはこれを広範囲に調査しました。
`list`パッケージを書きたいときに、ある要素型の`List`を別の要素型の`List`に変換する関数`Transform`をそのパッケージに含ませたいときに問題になります。
あるパッケージのあるインスタンスの関数が、同じパッケージの別のインスタンスを必要とする型を返すのは非常に厄介です。

また、パッケージの境界と型の定義を混同してしまいます。
一般的な型の使用がパッケージにきれいに分解されると考える特別な理由はありません。
そうなることもあれば、そうならないこともあります。

##### C++やJavaのように `F<T>` という構文を使うのはどうでしょうか？

関数内のコードを解析する際、`v:=F<T>`のように`<`を見る時点で、型のインスタンス化を見ているのか`<`演算子を使った式を見ているのかが曖昧になってしまいます。
これを解決するためには、実質的に束縛されていないルックヘッドが必要です。
一般的に、私たちはGoパーサを効率的に保つように努力しています。

##### なぜ構文 `F[T]` を使わないのですか？

型宣言`type A [T] int`を解析する際に、これが`int`として定義された(無駄に)ジェネリクス型なのか、それとも`T`要素を持つ配列型なのかが曖昧になります。
しかし、これはジェネリクス型に `type A [type T] int` を要求することで対処できます。

`func f(A[T]int)`(単一のパラメータで`[T]int`型のもの)や`func f(A[T], int)`(2つのパラメータで`A[T]`型と`int`型のもの)のような構文解析宣言は、
追加の構文解析ルックヘッドが必要であることを示しています。
これは解決可能ですが，解析が複雑になります．

この言語は一般的にカンマで区切られたリストの最後のカンマを許可しているので、
`A` がジェネリクス型の場合は `A[T,]` を許可しなければなりませんが
は通常、インデックス式では許可されません。
しかし、パーサは `A` がジェネリクス型なのかスライス型、配列型、マップ型の値なのかを知ることができないので、型チェックが完了するまでこの解析エラーを報告することができません。
繰り返しになりますが、解決は可能ですが複雑です。

より一般的には、`[]`はページに押し付けがましく、`()`の方がGoらしいと感じました。
この決定については、今後の経験を積んでいく中で再評価していきます。

##### なぜ`F«T»`を使わないのか？

検討しましたが、非ASCIIを要求する気にはなれませんでした。

##### ビルドインパッケージで制約を定義しないのはなぜですか？

_型リストを書き出す代わりに、`constraints.Arithmetic`や`constraints.Comparable`のような名前を使います。_

すべての可能な型の組み合わせをリストアップするのは、かなり長くなります。
また、ジェネリクスコードを書く人だけでなく、もっと重要なことに、読み手が覚えておかなければならない新しい名前のセットを導入することになります。
この設計の目的の一つは、新しい名前をできるだけ少なくすることです。
このデザインでは、新たに宣言された名前を1つだけ導入します。

人々がそのような名前が便利だと感じれば、他の型や関数で使用でき、他の制約に埋め込まれた制約の形で便利な名前を定義するパッケージ`constraints`を導入することができると期待しています。
これにより、標準ライブラリの中で最も有用な名前が定義され、プログラマは適切な場合には他の型の組み合わせを使用する柔軟性を持つことになります。

##### 型パラメータである値に対して型アサーションを許可しないのはなぜですか？

この設計の以前のバージョンでは、
型が型パラメータである変数、
または型が型パラメータに基づいている変数に対して、
型アサーションや型スイッチを使用することを許可していました。
この機能を削除したのは、任意の型の値を空のインタフェース型に変換して、
その値に対して型アサーションや型スイッチを使用することが常に可能だからです。
また、型リストを持つ制約では、型アサーションや型スイッチが、
型引数の基礎となる型ではなく実際の型引数を使用することで混乱することがありました。
(この違いについては、[一致した宣言済み型の識別](#一致した宣言済み型の識別) のセクションで説明しています)

#### Javaとの比較

Java ジェネリクスに対する不満の多くは、型の消去が中心です。
この設計では型の消去はありません。
ジェネリクス型の反映情報には、コンパイル時の完全な型情報が含まれます。

Javaでは、型のワイルドカード(`List<? extends Number>`, `List<? super Number>`)は共分散と逆分散を実装しています。
Goにはこれらの概念がないため、ジェネリクス型をよりシンプルにしています。

#### C++との比較

C++のテンプレートは、型の引数に制約を課しません。（概念案が採用されていない限り）
これは、テンプレートのコードを変更すると、
誤って遠く離れたインスタンスが壊れてしまう可能性があることを意味します。
また、エラーメッセージがインスタンス化時にのみ報告され、
深く入れ子になって理解しづらくなる可能性があることを意味します。
この設計では、明示的な必須制約によってこれらの問題を回避します。

C++はテンプレート・メタプログラミングをサポートしています。
これは、コンパイル時に非テンプレートC++とは全く異なる構文を使用して行われる通常のプログラミングと考えることができます。
この設計には、同様の機能はありません。
これにより、消費電力と実行時間の効率が失われる一方で、
かなりの複雑さを節約することができます。

C++では2段階の名前検索を使用しており、
一部の名前はテンプレート定義のコンテキストで検索され、
一部の名前はをテンプレートのインスタンス化のコンテキストで使用することができます。
この設計では、すべての名前は記述された時点で検索されます。

実際には、すべてのC++コンパイラは、テンプレートがインスタンス化された時点で各テンプレートをコンパイルします。
このため、コンパイル時間が遅くなることがあります。
このデザインでは、ジェネリクス関数のコンパイルをどのように処理するかについて柔軟性があります。

#### Rustとの比較

このデザインで記述されているジェネリクスは、Rustのジェネリクスに似ています。

1つの違いは、Rustでは、トレイト結合と型の関連付けは、トレイト結合を定義するトレイトか型を定義するトレイトの中で明示的に定義されなければならないということです。
Goの用語では、型が制約を満たすかどうかをどこかで宣言しなければならないことになります。
Goの型が明示的に宣言しなくてもGoのインターフェースを満たすことができるように、
このデザインでは、Goの型の引数が明示的に宣言しなくても制約を満たすことができます。

このデザインでは型リストを使用していますが、Rust標準ライブラリでは、比較などの操作のための標準的な特徴を定義しています。
これらの標準トレイトは、Rustのプリミティブ型によって自動的に実装されますが、ユーザー定義型によっても実装することができます。
Rustは、すべての演算子をカバーするトレイトのリストを提供しており、少なくとも34個のトレイトを提供しています。

Rustはメソッドの型パラメータをサポートしていますが、このデザインではサポートしていません。

## Examples

The following sections are examples of how this design could be used.
This is intended to address specific areas where people have created
user experience reports concerned with Go's lack of generics.

### Map/Reduce/Filter

Here is an example of how to write map, reduce, and filter functions
for slices.
These functions are intended to correspond to the similar functions in
Lisp, Python, Java, and so forth.

```Go
// Package slices implements various slice algorithms.
package slices

// Map turns a []T1 to a []T2 using a mapping function.
// This function has two type parameters, T1 and T2.
// There are no constraints on the type parameters,
// so this works with slices of any type.
func Map(type T1, T2)(s []T1, f func(T1) T2) []T2 {
	r := make([]T2, len(s))
	for i, v := range s {
		r[i] = f(v)
	}
	return r
}

// Reduce reduces a []T1 to a single value using a reduction function.
func Reduce(type T1, T2)(s []T1, initializer T2, f func(T2, T1) T2) T2 {
	r := initializer
	for _, v := range s {
		r = f(r, v)
	}
	return r
}

// Filter filters values from a slice using a filter function.
// It returns a new slice with only the elements of s
// for which f returned true.
func Filter(type T)(s []T, f func(T) bool) []T {
	var r []T
	for _, v := range s {
		if f(v) {
			r = append(r, v)
		}
	}
	return r
}
```

Here are some example calls of these functions.
Type inference is used to determine the type arguments based on the
types of the non-type arguments.

```Go
	s := []int{1, 2, 3}

	floats := slices.Map(s, func(i int) float64 { return float64(i) })
	// Now floats is []float64{1.0, 2.0, 3.0}.

	sum := slices.Reduce(s, 0, func(i, j int) int { return i + j })
	// Now sum is 6.

	evens := slices.Filter(s, func(i int) bool { return i%2 == 0 })
	// Now evens is []int{2}.
```

### Map keys

Here is how to get a slice of the keys of any map.

```Go
// Package maps provides general functions that work for all map types.
package maps

// Keys returns the keys of the map m in a slice.
// The keys will be returned in an unpredictable order.
// This function has two type parameters, K and V.
// Map keys must be comparable, so key has the predeclared
// constraint comparable. Map values can be any type;
// the empty interface type imposes no constraints.
func Keys(type K comparable, V interface{})(m map[K]V) []K {
	r := make([]K, 0, len(m))
	for k := range m {
		r = append(r, k)
	}
	return r
}
```

In typical use the map key and val types will be inferred.

```Go
	k := maps.Keys(map[int]int{1:2, 2:4})
	// Now k is either []int{1, 2} or []int{2, 1}.
```

### Sets

Many people have asked for Go's builtin map type to be extended, or
rather reduced, to support a set type.
Here is a type-safe implementation of a set type, albeit one that uses
methods rather than operators like `[]`.

```Go
// Package set implements sets of any comparable type.
package set

// Set is a set of values.
type Set(type T comparable) map[T]struct{}

// Make returns a set of some element type.
func Make(type T comparable)() Set(T) {
	return make(Set(T))
}

// Add adds v to the set s.
// If v is already in s this has no effect.
func (s Set(T)) Add(v T) {
	s[v] = struct{}{}
}

// Delete removes v from the set s.
// If v is not in s this has no effect.
func (s Set(T)) Delete(v T) {
	delete(s, v)
}

// Contains reports whether v is in s.
func (s Set(T)) Contains(v T) bool {
	_, ok := s[v]
	return ok
}

// Len reports the number of elements in s.
func (s Set(T)) Len() int {
	return len(s)
}

// Iterate invokes f on each element of s.
// It's OK for f to call the Delete method.
func (s Set(T)) Iterate(f func(T)) {
	for v := range s {
		f(v)
	}
}
```

Example use:

```Go
	// Create a set of ints.
	// We pass (int) as a type argument.
	// Then we write () because Make does not take any non-type arguments.
	// We have to pass an explicit type argument to Make.
	// Type inference doesn't work because the type argument
	// to Make is only used for a result parameter type.
	s := set.Make(int)()

	// Add the value 1 to the set s.
	s.Add(1)

	// Check that s does not contain the value 2.
	if s.Contains(2) { panic("unexpected 2") }
```

This example shows how to use this design to provide a compile-time
type-safe wrapper around an existing API.

### Sort

Before the introduction of `sort.Slice`, a common complaint was the
need for boilerplate definitions in order to use `sort.Sort`.
With this design, we can add to the sort package as follows:

```Go
// Ordered is a type constraint that matches all ordered types.
// (An ordered type is one that supports the < <= >= > operators.)
// In practice this type constraint would likely be defined in
// a standard library package.
type Ordered interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		string
}

// orderedSlice is an internal type that implements sort.Interface.
// The Less method uses the < operator. The Ordered type constraint
// ensures that T has a < operator.
type orderedSlice(type T Ordered) []T

func (s orderedSlice(T)) Len() int           { return len(s) }
func (s orderedSlice(T)) Less(i, j int) bool { return s[i] < s[j] }
func (s orderedSlice(T)) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

// OrderedSlice sorts the slice s in ascending order.
// The elements of s must be ordered using the < operator.
func OrderedSlice(type T Ordered)(s []T) {
	// Convert s to the type orderedSlice(T).
	// As s is []T, and orderedSlice(T) is defined as []T,
	// this conversion is permitted.
	// orderedSlice(T) implements sort.Interface,
	// so can pass the result to sort.Sort.
	// The elements will be sorted using the < operator.
	sort.Sort(orderedSlice(T)(s))
}
```

Now we can write:

```Go
	s1 := []int32{3, 5, 2}
	sort.OrderedSlice(s1)
	// Now s1 is []int32{2, 3, 5}

	s2 := []string{"a", "c", "b"})
	sort.OrderedSlice(s2)
	// Now s2 is []string{"a", "b", "c"}
```

Along the same lines, we can add a function for sorting using a
comparison function, similar to `sort.Slice` but writing the function
to take values rather than slice indexes.

```Go
// sliceFn is an internal type that implements sort.Interface.
// The Less method calls the cmp field.
type sliceFn(type T) struct {
	s   []T
	cmp func(T, T) bool
}

func (s sliceFn(T)) Len() int           { return len(s.s) }
func (s sliceFn(T)) Less(i, j int) bool { return s.cmp(s.s[i], s.s[j]) }
func (s sliceFn(T)) Swap(i, j int)      { s.s[i], s.s[j] = s.s[j], s.s[i] }

// SliceFn sorts the slice s according to the function cmp.
func SliceFn(type T)(s []T, cmp func(T, T) bool) {
	Sort(sliceFn(E){s, cmp})
}
```

An example of calling this might be:

```Go
	var s []*Person
	// ...
	sort.SliceFn(s, func(p1, p2 *Person) bool { return p1.Name < p2.Name })
```

### Channels

Many simple general purpose channel functions are never written,
because they must be written using reflection and the caller must type
assert the results.
With this design they become straightforward to write.

```Go
// Package chans implements various channel algorithms.
package chans

import "runtime"

// Ranger provides a convenient way to exit a goroutine sending values
// when the receiver stops reading them.
//
// Ranger returns a Sender and a Receiver. The Receiver provides a
// Next method to retrieve values. The Sender provides a Send method
// to send values and a Close method to stop sending values. The Next
// method indicates when the Sender has been closed, and the Send
// method indicates when the Receiver has been freed.
func Ranger(type T)() (*Sender(T), *Receiver(T)) {
	c := make(chan T)
	d := make(chan bool)
	s := &Sender(T){values: c, done: d}
	r := &Receiver(T){values: c, done: d}
	// The finalizer on the receiver will tell the sender
	// if the receiver stops listening.
	runtime.SetFinalizer(r, r.finalize)
	return s, r
}

// A Sender is used to send values to a Receiver.
type Sender(type T) struct {
	values chan<- T
	done   <-chan bool
}

// Send sends a value to the receiver. It reports whether any more
// values may be sent; if it returns false the value was not sent.
func (s *Sender(T)) Send(v T) bool {
	select {
	case s.values <- v:
		return true
	case <-s.done:
		// The receiver has stopped listening.
		return false
	}
}

// Close tells the receiver that no more values will arrive.
// After Close is called, the Sender may no longer be used.
func (s *Sender(T)) Close() {
	close(s.values)
}

// A Receiver receives values from a Sender.
type Receiver(type T) struct {
	values <-chan T
	done  chan<- bool
}

// Next returns the next value from the channel. The bool result
// reports whether the value is valid. If the value is not valid, the
// Sender has been closed and no more values will be received.
func (r *Receiver(T)) Next() (T, bool) {
	v, ok := <-r.values
	return v, ok
}

// finalize is a finalizer for the receiver.
// It tells the sender that the receiver has stopped listening.
func (r *Receiver(T)) finalize() {
	close(r.done)
}
```

There is an example of using this function in the next section.

### Containers

One of the frequent requests for generics in Go is the ability to
write compile-time type-safe containers.
This design makes it easy to write a compile-time type-safe wrapper
around an existing container; we won't write out an example for that.
This design also makes it easy to write a compile-time type-safe
container that does not use boxing.

Here is an example of an ordered map implemented as a binary tree.
The details of how it works are not too important.
The important points are:

* The code is written in a natural Go style, using the key and value
  types where needed.
* The keys and values are stored directly in the nodes of the tree,
  not using pointers and not boxed as interface values.

```Go
// Package orderedmap provides an ordered map, implemented as a binary tree.
package orderedmap

import "chans"

// Map is an ordered map.
type Map(type K, V) struct {
	root    *node(K, V)
	compare func(K, K) int
}

// node is the type of a node in the binary tree.
type node(type K, V) struct {
	k           K
	v           V
	left, right *node(K, V)
}

// New returns a new map.
// Since the type parameter V is only used for the result,
// type inference does not work, and calls to New must always
// pass explicit type arguments.
func New(type K, V)(compare func(K, K) int) *Map(K, V) {
	return &Map(K, V){compare: compare}
}

// find looks up k in the map, and returns either a pointer
// to the node holding k, or a pointer to the location where
// such a node would go.
func (m *Map(K, V)) find(k K) **node(K, V) {
	pn := &m.root
	for *pn != nil {
		switch cmp := m.compare(k, (*pn).k); {
		case cmp < 0:
			pn = &(*pn).left
		case cmp > 0:
			pn = &(*pn).right
		default:
			return pn
		}
	}
	return pn
}

// Insert inserts a new key/value into the map.
// If the key is already present, the value is replaced.
// Reports whether this is a new key.
func (m *Map(K, V)) Insert(k K, v V) bool {
	pn := m.find(k)
	if *pn != nil {
		(*pn).v = v
		return false
	}
	*pn = &node(K, V){k: k, v: v}
	return true
}

// Find returns the value associated with a key, or zero if not present.
// The bool result reports whether the key was found.
func (m *Map(K, V)) Find(k K) (V, bool) {
	pn := m.find(k)
	if *pn == nil {
		var zero V // see the discussion of zero values, above
		return zero, false
	}
	return (*pn).v, true
}

// keyValue is a pair of key and value used when iterating.
type keyValue(type K, V) struct {
	k K
	v V
}

// InOrder returns an iterator that does an in-order traversal of the map.
func (m *Map(K, V)) InOrder() *Iterator(K, V) {
	type kv = keyValue(K, V) // convenient shorthand
	sender, receiver := chans.Ranger(kv)()
	var f func(*node(K, V)) bool
	f = func(n *node(K, V)) bool {
		if n == nil {
			return true
		}
		// Stop sending values if sender.Send returns false,
		// meaning that nothing is listening at the receiver end.
		return f(n.left) &&
			sender.Send(kv{n.k, n.v}) &&
			f(n.right)
	}
	go func() {
		f(m.root)
		sender.Close()
	}()
	return &Iterator{receiver}
}

// Iterator is used to iterate over the map.
type Iterator(type K, V) struct {
	r *chans.Receiver(keyValue(K, V))
}

// Next returns the next key and value pair. The bool result reports
// whether the values are valid. If the values are not valid, we have
// reached the end.
func (it *Iterator(K, V)) Next() (K, V, bool) {
	kv, ok := it.r.Next()
	return kv.k, kv.v, ok
}
```

This is what it looks like to use this package:

```Go
import "container/orderedmap"

// Set m to an ordered map from string to string,
// using strings.Compare as the comparison function.
var m = orderedmap.New(string, string)(strings.Compare)

// Add adds the pair a, b to m.
func Add(a, b string) {
	m.Insert(a, b)
}
```

### Append

The predeclared `append` function exists to replace the boilerplate
otherwise required to grow a slice.
Before `append` was added to the language, there was a function `Add`
in the bytes package:

```Go
// Add appends the contents of t to the end of s and returns the result.
// If s has enough capacity, it is extended in place; otherwise a
// new array is allocated and returned.
func Add(s, t []byte) []byte
```

`Add` appended two `[]byte` values together, returning a new slice.
That was fine for `[]byte`, but if you had a slice of some other
type, you had to write essentially the same code to append more
values.
If this design were available back then, perhaps we would not have
added `append` to the language.
Instead, we could write something like this:

```Go
// Package slices implements various slice algorithms.
package slices

// Append appends the contents of t to the end of s and returns the result.
// If s has enough capacity, it is extended in place; otherwise a
// new array is allocated and returned.
func Append(type T)(s []T, t ...T) []T {
	lens := len(s)
	tot := lens + len(t)
	if tot < 0 {
		panic("Append: cap out of range")
	}
	if tot > cap(s) {
		news := make([]T, tot, tot + tot/2)
		copy(news, s)
		s = news
	}
	s = s[:tot]
	copy(s[lens:], t)
	return s
}
```

That example uses the predeclared `copy` function, but that's OK, we
can write that one too:

```Go
// Copy copies values from t to s, stopping when either slice is
// full, returning the number of values copied.
func Copy(type T)(s, t []T) int {
	i := 0
	for ; i < len(s) && i < len(t); i++ {
		s[i] = t[i]
	}
	return i
}
```

These functions can be used as one would expect:

```Go
	s := slices.Append([]int{1, 2, 3}, 4, 5, 6)
	// Now s is []int{1, 2, 3, 4, 5, 6}.
	slices.Copy(s[3:], []int{7, 8, 9})
	// Now s is []int{1, 2, 3, 7, 8, 9}
```

This code doesn't implement the special case of appending or copying a
`string` to a `[]byte`, and it's unlikely to be as efficient as the
implementation of the predeclared function.
Still, this example shows that using this design would permit `append`
and `copy` to be written generically, once, without requiring any
additional special language features.

### Metrics

In a [Go experience
report](https://medium.com/@sameer_74231/go-experience-report-for-generics-google-metrics-api-b019d597aaa4)
Sameer Ajmani describes a metrics implementation.
Each metric has a value and one or more fields.
The fields have different types.
Defining a metric requires specifying the types of the fields, and
creating a value with an Add method.
The Add method takes the field types as arguments, and records an
instance of that set of fields.
The C++ implementation uses a variadic template.
The Java implementation includes the number of fields in the name of
the type.
Both the C++ and Java implementations provide compile-time type-safe
Add methods.

Here is how to use this design to provide similar functionality in
Go with a compile-time type-safe Add method.
Because there is no support for a variadic number of type arguments,
we must use different names for a different number of arguments, as in
Java.
This implementation only works for comparable types.
A more complex implementation could accept a comparison function to
work with arbitrary types.

```Go
// Package metrics provides a general mechanism for accumulating
// metrics of different values.
package metrics

import "sync"

// Metric1 accumulates metrics of a single value.
type Metric1(type T comparable) struct {
	mu sync.Mutex
	m  map[T]int
}

// Add adds an instance of a value.
func (m *Metric1(T)) Add(v T) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.m == nil {
		m.m = make(map[T]int)
	}
	m.m[v]++
}

// key2 is an internal type used by Metric2.
type key2(type T1, T2 comparable) struct {
	f1 T1
	f2 T2
}

// Metric2 accumulates metrics of pairs of values.
type Metric2(type T1, T2 comparable) struct {
	mu sync.Mutex
	m  map[key2(T1, T2)]int
}

// Add adds an instance of a value pair.
func (m *Metric2(T1, T2)) Add(v1 T1, v2 T2) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.m == nil {
		m.m = make(map[key2(T1, T2)]int)
	}
	m.m[key2(T1, T2){v1, v2}]++
}

// key3 is an internal type used by Metric3.
type key3(type T1, T2, T3 comparable) struct {
	f1 T1
	f2 T2
	f3 T3
}

// Metric3 accumulates metrics of triples of values.
type Metric3(type T1, T2, T3 comparable) struct {
	mu sync.Mutex
	m  map[key3(T1, T2, T3)]int
}

// Add adds an instance of a value triplet.
func (m *Metric3(T1, T2, T3)) Add(v1 T1, v2 T2, v3 T3) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.m == nil {
		m.m = make(map[key3(T1, T2, T3)]int)
	}
	m.m[key3(T1, T2, T3){v1, v2, v3}]++
}

// Repeat for the maximum number of permitted arguments.
```

Using this package looks like this:

```Go
import "metrics"

var m = metrics.Metric2(string, int){}

func F(s string, i int) {
	m.Add(s, i) // this call is type checked at compile time
}
```

This implementation has a certain amount of repetition due to the lack
of support for variadic type parameters.
Using the package, though, is easy and type safe.

### List transform

While slices are efficient and easy to use, there are occasional cases
where a linked list is appropriate.
This example primarily shows transforming a linked list of one type to
another type, as an example of using different instantiations of the
same generic type.

```Go
// Package list provides a linked list of any type.
package list

// List is a linked list.
type List(type T) struct {
	head, tail *element(T)
}

// An element is an entry in a linked list.
type element(type T) struct {
	next *element(T)
	val  T
}

// Push pushes an element to the end of the list.
func (lst *List(T)) Push(v T) {
	if lst.tail == nil {
		lst.head = &element(T){val: v}
		lst.tail = lst.head
	} else {
		lst.tail.next = &element(T){val: v }
		lst.tail = lst.tail.next
	}
}

// Iterator ranges over a list.
type Iterator(type T) struct {
	next **element(T)
}

// Range returns an Iterator starting at the head of the list.
func (lst *List(T)) Range() *Iterator(T) {
	return Iterator(T){next: &lst.head}
}

// Next advances the iterator.
// It reports whether there are more elements.
func (it *Iterator(T)) Next() bool {
	if *it.next == nil {
		return false
	}
	it.next = &(*it.next).next
	return true
}

// Val returns the value of the current element.
// The bool result reports whether the value is valid.
func (it *Iterator(T)) Val() (T, bool) {
	if *it.next == nil {
		var zero T
		return zero, false
	}
	return (*it.next).val, true
}

// Transform runs a transform function on a list returning a new list.
func Transform(type T1, T2)(lst *List(T1), f func(T1) T2) *List(T2) {
	ret := &List(T2){}
	it := lst.Range()
	for {
		if v, ok := it.Val(); ok {
			ret.Push(f(v))
		}
		if !it.Next() {
			break
		}
	}
	return ret
}
```

### Dot product

A generic dot product implementation that works for slices of any
numeric type.

```Go
// Numeric is a constraint that matches any numeric type.
// It would likely be in a constraints package in the standard library.
type Numeric interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		complex64, complex128
}

// DotProduct returns the dot product of two slices.
// This panics if the two slices are not the same length.
func DotProduct(type T Numeric)(s1, s2 []T) T {
	if len(s1) != len(s2) {
		panic("DotProduct: slices of unequal length")
	}
	var r T
	for i := range s1 {
		r += s1[i] * s2[i]
	}
	return r
}
```

(Note: the generics implementation approach may affect whether
`DotProduct` uses FMA, and thus what the exact results are when using
floating point types.
It's not clear how much of a problem this is, or whether there is any
way to fix it.)

### Absolute difference

Compute the absolute difference between two numeric values, by using
an `Abs` method.
This uses the same `Numeric` constraint defined in the last example.

This example uses more machinery than is appropriate for the simple
case of computing the absolute difference.
It is intended to show how the common part of algorithms can be
factored into code that uses methods, where the exact definition of
the methods can vary based on the kind of type being used.

```Go
// NumericAbs matches numeric types with an Abs method.
type NumericAbs(type T) interface {
	Numeric
	Abs() T
}

// AbsDifference computes the absolute value of the difference of
// a and b, where the absolute value is determined by the Abs method.
func AbsDifference(type T NumericAbs)(a, b T) T {
	d := a - b
	return d.Abs()
}
```

We can define an `Abs` method appropriate for different numeric types.

```Go
// OrderedNumeric matches numeric types that support the < operator.
type OrderedNumeric interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64
}

// Complex matches the two complex types, which do not have a < operator.
type Complex interface {
	type complex64, complex128
}

// OrderedAbs is a helper type that defines an Abs method for
// ordered numeric types.
type OrderedAbs(type T OrderedNumeric) T

func (a OrderedAbs(T)) Abs() OrderedAbs(T) {
	if a < 0 {
		return -a
	}
	return a
}

// ComplexAbs is a helper type that defines an Abs method for
// complex types.
type ComplexAbs(type T Complex) T

func (a ComplexAbs(T)) Abs() ComplexAbs(T) {
	d := math.Hypot(float64(real(a)), float64(imag(a)))
	return ComplexAbs(T)(complex(d, 0))
}
```

We can then define functions that do the work for the caller by
converting to and from the types we just defined.

```Go
// OrderedAbsDifference returns the absolute value of the difference
// between a and b, where a and b are of an ordered type.
func OrderedAbsDifference(type T OrderedNumeric)(a, b T) T {
	return T(AbsDifference(OrderedAbs(T)(a), OrderedAbs(T)(b)))
}

// ComplexAbsDifference returns the absolute value of the difference
// between a and b, where a and b are of a complex type.
func ComplexAbsDifference(type T Complex)(a, b T) T {
	return T(AbsDifference(ComplexAbs(T)(a), ComplexAbs(T)(b)))
}
```

It's worth noting that this design is not powerful enough to write
code like the following:

```Go
// This function is INVALID.
func GeneralAbsDifference(type T Numeric)(a, b T) T {
	switch (interface{})(a).(type) {
	case int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64:
		return OrderedAbsDifference(a, b) // INVALID
	case complex64, complex128:
		return ComplexAbsDifference(a, b) // INVALID
	}
}
```

The calls to `OrderedAbsDifference` and `ComplexAbsDifference` are
invalid, because not all the types that implement the `Numeric`
constraint can implement the `OrderedNumeric` or `Complex`
constraints.
Although the type switch means that this code would conceptually work
at run time, there is no support for writing this code at compile
time.
This is another way of expressing one of the omissions listed above:
this design does not provide for specialization.

## Acknowledgements

We'd like to thank many people on the Go team, many contributors to
the Go issue tracker, and all the people who have shared their ideas
and their feedback on earlier design drafts.
We read all of it, and we're grateful.

For this design draft in particular we received detailed feedback from
Josh Bleecher-Snyder, Jon Bodner, Dave Cheney, Jaana Dogan, Kevin
Gillette, Mitchell Hashimoto, Chris Hines, Bill Kennedy, Ayke van
Laethem, Daniel Martí, Elena Morozova, Roger Peppe, and Ronna
Steinberg.

## Appendix

This appendix covers various details of the design that don't seem
significant enough to cover in earlier sections.

### Generic type aliases

A type alias may refer to a generic type, but the type alias may not
have its own parameters.
This restriction exists because it is unclear how to handle a type
alias with type parameters that have constraints.

```Go
type VectorAlias = Vector
```

In this case uses of the type alias will have to provide type
arguments appropriate for the generic type being aliased.

```Go
var v VectorAlias(int)
```

Type aliases may also refer to instantiated types.

```Go
type VectorInt = Vector(int)
```

### Instantiating a function

Go normally permits you to refer to a function without passing any
arguments, producing a value of function type.
You may not do this with a function that has type parameters; all type
arguments must be known at compile time.
That said, you can instantiate the function, by passing type
arguments, but you don't have to call the instantiation.
This will produce a function value with no type parameters.

```Go
// PrintInts is type func([]int).
var PrintInts = Print(int)
```

### Embedded type parameter

When a generic type is a struct, and the type parameter is
embedded as a field in the struct, the name of the field is the name
of the type parameter.

```Go
// A Lockable is a value that may be safely simultaneously accessed
// from multiple goroutines via the Get and Set methods.
type Lockable(type T) struct {
	T
	mu sync.Mutex
}

// Get returns the value stored in a Lockable.
func (l *Lockable(T)) Get() T {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.T
}

// Set sets the value in a Lockable.
func (l *Lockable(T)) Set(v T) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.T = v
}
```

### Inline constraints

As we've seen in examples that use `interface{}` as a type constraint,
it's not necessary for a constraint to use a named interface type.
A type parameter list can use an interface type literal, just as an
ordinary parameter list can use a type literal for a parameter type.

```Go
// Stringify calls the String method on each element of s,
// and returns the results.
func Stringify(type T interface { String() string })(s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String())
	}
	return ret
}
```

### Type inference for composite literals

This is a feature we are not suggesting now, but could consider for
later versions of the language.

We could also consider supporting type inference for composite
literals of generic types.

```Go
type Pair(type T) struct { f1, f2 T }
var V = Pair{1, 2} // inferred as Pair(int){1, 2}
```

It's not clear how often this will arise in real code.

### Type inference for generic function arguments

This is a feature we are not suggesting now, but could consider for
later versions of the language.

In the following example, consider the call to `Find` in `FindClose`.
Type inference can determine that the type argument to `Find` is `T4`,
and from that we know that the type of the final argument must be
`func(T4, T4) bool`, and from that we could deduce that the type
argument to `IsClose` must also be `T4`.
However, the type inference algorithm described earlier cannot do
that, so we must explicitly write `IsClose(T4)`.

This may seem esoteric at first, but it comes up when passing generic
functions to generic `Map` and `Filter` functions.

```Go
// Differ has a Diff method that returns how different a value is.
type Differ(type T1) interface {
	Diff(T1) int
}

// IsClose returns whether a and b are close together, based on Diff.
func IsClose(type T2 Differ)(a, b T2) bool {
	return a.Diff(b) < 2
}

// Find returns the index of the first element in s that matches e,
// based on the cmp function. It returns -1 if no element matches.
func Find(type T3)(s []T3, e T3, cmp func(a, b T3) bool) int {
	for i, v := range s {
		if cmp(v, e) {
			return i
		}
	}
	return -1
}

// FindClose returns the index of the first element in s that is
// close to e, based on IsClose.
func FindClose(type T4 Differ)(s []T4, e T4) int {
	// With the current type inference algorithm we have to
	// explicitly write IsClose(T4) here, although it
	// is the only type argument we could possibly use.
	return Find(s, e, IsClose(T4))
}
```

### Reflection on type arguments

Although we don't suggest changing the reflect package, one
possibility to consider for the future would be to add two new
methods to `reflect.Type`: `NumTypeArgument() int` would return the
number of type arguments to a type, and `TypeArgument(i) Type` would
return the i'th type argument.
`NumTypeArgument` would return non-zero for an instantiated generic
type.
Similar methods could be defined for `reflect.Value`, for which
`NumTypeArgument` would return non-zero for an instantiated generic
function.
There might be some kind of programs that would care about this
information.

### Instantiating types in type literals

When instantiating a type at the end of a type literal, there is a
parsing ambiguity.

```Go
x1 := []T(v1)
x2 := []T(v2){}
```

In this example, the first case is a type conversion of `v1` to the
type `[]T`.
The second case is a composite literal of type `[]T(v2)`, where `T` is
a generic type that we are instantiating with the type argument `v2`.
The ambiguity is at the point where we see the open parenthesis: at
that point the parser doesn't know whether it is seeing a type
conversion or something like a composite literal.

To avoid this ambiguity, we require that type instantiations at the
end of a type literal be parenthesized.
To write a type literal that is a slice of a type instantiation, you
must write `[](T(v1))`.
Without those parentheses, `[]T(x)` is parsed as `([]T)(x)`, not as
`[](T(x))`.
This only applies to slice, array, map, chan, and func type literals
ending in a type name.
Of course it is always possible to use a separate type declaration to
give a name to the instantiated type, and to use that.

### Embedding an instantiated interface type

There is a parsing ambiguity when embedding an instantiated interface
type in another interface type.

```Go
type I1(type T) interface {
	M(T)
}

type I2 interface {
	I1(int)
}
```

In this example we don't know whether interface `I2` has a single
method named `I1` that takes an argument of type `int`, or whether we
are trying to embed the instantiated type `I1(int)` into `I2`.

For backward compatibility, we treat this as the former case: `I2` has
a method named `I1`.

In order to embed an instantiated interface type, we require
that extra parentheses be used.

```Go
type I2 interface {
	(I1(int))
}
```

This is currently not permitted by the language, and will be a
relaxation of the existing rules.

The same applies to embedding an instantiated type in a struct.

```Go
type S1 struct {
	T(int) // field named T of type int
}

type S2 struct {
	(T(int)) // embedded field of type T(int)
}
```

The field name of an embedded field of type `T(int)` is simply `T`.
